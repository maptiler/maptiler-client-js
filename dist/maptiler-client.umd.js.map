{"version":3,"file":"maptiler-client.umd.js","sources":["../src/config.ts","../src/language.ts","../src/callFetch.ts","../src/defaults.ts","../src/services/ServiceError.ts","../src/services/geocoding.ts","../src/services/geolocation.ts","../src/services/coordinates.ts","../src/services/data.ts","../src/mapstyle.ts","../src/services/simplify.ts","../src/services/staticMaps.ts","../node_modules/web-merc-projection/dist/index.js","../src/geometry/util.ts","../src/geometry/area.ts","../src/geometry/distance.ts","../src/demProfiler/tileCover.ts","../src/demProfiler/getElevation.ts","../src/demProfiler/index.ts"],"sourcesContent":["export type FetchFunction = (url: string, options: object) => Promise<any>;\n\nfunction tryGettingFetch() {\n  // this is browser, fetch exists\n  if (typeof self !== \"undefined\") {\n    return fetch.bind(self);\n  }\n\n  if (typeof global !== \"undefined\" && global.fetch) {\n    return global.fetch;\n  }\n\n  return null;\n}\n\n/**\n * The configuration object definition\n */\nclass ClientConfig {\n  /**\n   * MapTiler Cloud API key\n   */\n  private _apiKey = \"\";\n\n  /**\n   * The fetch function. To be set if in Node < 18, otherwise\n   * will be automatically resolved.\n   */\n  private _fetch: FetchFunction | null = tryGettingFetch();\n\n  /**\n   * Set the MapTiler Cloud API key\n   */\n  set apiKey(k: string) {\n    this._apiKey = k;\n  }\n\n  /**\n   * Get the MapTiler Cloud API key\n   */\n  get apiKey(): string {\n    return this._apiKey;\n  }\n\n  /**\n   * Set a the custom fetch function to replace the default one\n   */\n  set fetch(f: FetchFunction) {\n    this._fetch = f;\n  }\n\n  /**\n   * Get the fetch fucntion\n   */\n  get fetch(): FetchFunction | null {\n    return this._fetch;\n  }\n}\n\n/**\n * Configuration object\n */\nconst config = new ClientConfig();\n\nexport { ClientConfig, config };\n","/**\n * Languages. Note that not all the languages of this list are available but the compatibility list may be expanded in the future.\n */\nconst LanguageGeocoding = {\n  AUTO: \"auto\",\n  ALBANIAN: \"sq\",\n  ARABIC: \"ar\",\n  ARMENIAN: \"hy\",\n  AZERBAIJANI: \"az\",\n  BELORUSSIAN: \"be\",\n  BOSNIAN: \"bs\",\n  BRETON: \"br\",\n  BULGARIAN: \"bg\",\n  CATALAN: \"ca\",\n  CHINESE: \"zh\",\n  CROATIAN: \"hr\",\n  CZECH: \"cs\",\n  DANISH: \"da\",\n  DUTCH: \"nl\",\n  ENGLISH: \"en\",\n  ESPERANTO: \"eo\",\n  ESTONIAN: \"et\",\n  FINNISH: \"fi\",\n  FRENCH: \"fr\",\n  FRISIAN: \"fy\",\n  GEORGIAN: \"ka\",\n  GERMAN: \"de\",\n  GREEK: \"el\",\n  HEBREW: \"he\",\n  HUNGARIAN: \"hu\",\n  ICELANDIC: \"is\",\n  IRISH: \"ga\",\n  ITALIAN: \"it\",\n  JAPANESE: \"ja\",\n  KANNADA: \"kn\",\n  KAZAKH: \"kk\",\n  KOREAN: \"ko\",\n  ROMAN_LATIN: \"la\",\n  LATVIAN: \"lv\",\n  LITHUANIAN: \"lt\",\n  LUXEMBOURGISH: \"lb\",\n  MACEDONIAN: \"mk\",\n  MALTESE: \"mt\",\n  NORWEGIAN: \"no\",\n  POLISH: \"pl\",\n  PORTUGUESE: \"pt\",\n  ROMANIAN: \"ro\",\n  ROMANSH: \"rm\",\n  RUSSIAN: \"ru\",\n  SCOTTISH_GAELIC: \"gd\",\n  SERBIAN_CYRILLIC: \"sr\",\n  SLOVAK: \"sk\",\n  SLOVENE: \"sl\",\n  SPANISH: \"es\",\n  SWEDISH: \"sv\",\n  THAI: \"th\",\n  TURKISH: \"tr\",\n  UKRAINIAN: \"uk\",\n  WELSH: \"cy\",\n};\n\nconst languageCodeSet = new Set(Object.values(LanguageGeocoding));\n\ntype Values<T> = T[keyof T];\n\n/**\n * Built-in languages values as strings\n */\ntype LanguageGeocodingString = Values<typeof LanguageGeocoding>;\n\nfunction getAutoLanguageGeocoding(): LanguageGeocodingString {\n  if (typeof navigator === \"undefined\") {\n    return Intl.DateTimeFormat()\n      .resolvedOptions()\n      .locale.split(\"-\")[0] as LanguageGeocodingString;\n  }\n\n  const canditatelangs = Array.from(\n    new Set(navigator.languages.map((l) => l.split(\"-\")[0]))\n  ).filter((l) => languageCodeSet.has(l as LanguageGeocodingString));\n\n  return canditatelangs.length\n    ? (canditatelangs[0] as LanguageGeocodingString)\n    : LanguageGeocoding.ENGLISH;\n}\n\nexport { LanguageGeocoding, LanguageGeocodingString, getAutoLanguageGeocoding };\n","import { config } from \"./config\";\n\nexport async function callFetch(resource, options = {}) {\n  if (config.fetch === null) {\n    throw new Error(\n      \"The fetch function was not found. If on NodeJS < 18 please specify the fetch function with config.fetch\"\n    );\n  }\n\n  //  Control if URL contains the api key\n  if (new URL(resource).searchParams.get(\"key\").trim() === \"\") {\n    throw new Error(\n      \"The MapTiler Cloud API key is missing. Set it in `config.apiKey` or get one for free at https://maptiler.com\"\n    );\n  }\n\n  return config.fetch(resource, options);\n}\n","/**\n * Some default settings for the SDK\n */\nconst defaults = {\n  maptilerApiURL: \"https://api.maptiler.com/\",\n  mapStyle: \"streets-v2\",\n};\n\nObject.freeze(defaults);\n\nexport { defaults };\n","/**\n * A ServiceError is an Error that includes the HTTP response details\n */\nexport class ServiceError extends Error {\n  constructor(public res: Response, customMessage = \"\") {\n    super(\n      `Call to enpoint ${res.url} failed with the status code ${res.status}. ${customMessage}`\n    );\n  }\n}\n","import { BBox, Feature, Geometry, Position } from \"geojson\";\nimport { callFetch } from \"../callFetch\";\nimport { config } from \"../config\";\nimport { defaults } from \"../defaults\";\n\nimport {\n  getAutoLanguageGeocoding,\n  LanguageGeocoding,\n  LanguageGeocodingString,\n} from \"../language\";\nimport { ServiceError } from \"./ServiceError\";\n\nconst customMessages = {\n  400: \"Query too long / Invalid parameters\",\n  403: \"Key is missing, invalid or restricted\",\n};\n\nexport type LanguageGeocodingOptions = {\n  /**\n   * Prefer results in specific language. Itâ€™s possible to specify multiple values.\n   */\n  language?: LanguageGeocodingString | Array<LanguageGeocodingString>;\n};\n\nexport type CommonForwardAndReverseGeocodingOptions =\n  LanguageGeocodingOptions & {\n    /**\n     * Custom MapTiler Cloud API key to use instead of the one in global `config`\n     */\n    apiKey?: string;\n\n    /**\n     * Maximum number of results to show. Must be between 1 and 10. Default is 5 for forward and 1 for reverse geocoding.\n     */\n    limit?: number;\n\n    /**\n     * Filter of feature types to return. If not specified, all available feature types are returned.\n     */\n    types?: (\n      | \"country\"\n      | \"region\"\n      | \"subregion\"\n      | \"county\"\n      | \"joint_municipality\"\n      | \"joint_submunicipality\"\n      | \"municipality\"\n      | \"municipal_district\"\n      | \"locality\"\n      | \"neighbourhood\"\n      | \"place\"\n      | \"postal_code\"\n      | \"address\"\n      | \"poi\"\n    )[];\n  };\n\nexport type GeocodingOptions = CommonForwardAndReverseGeocodingOptions & {\n  /**\n   * Only search for results in the specified area.\n   */\n  bbox?: BBox;\n\n  /**\n   * Prefer results close to a specific location.\n   */\n  proximity?: Position;\n\n  /**\n   * Limit search to specific country/countries specified as list of Alpha-2 ISO 3166-1 codes.\n   */\n  country?: string[];\n\n  /**\n   * Set to `false` to disable fuzzy (typo-tolerant) search. Default is `true`.\n   */\n  fuzzyMatch?: boolean;\n\n  /**\n   * Set to `true` to use autocomplete, `false` to disable it.\n   * Default (`undefined`) is to combine autocomplete with non-autocomplete results.\n   */\n  autocomplete?: boolean;\n};\n\nexport type ReverseGeocodingOptions = CommonForwardAndReverseGeocodingOptions;\n\nexport type ByIdGeocodingOptions = LanguageGeocodingOptions;\n\nexport type Coordinates = Position;\n\ntype FeatureProperties = {\n  /**\n   * External reference of the feature used for debugging purposes\n   */\n  ref: string;\n\n  /**\n   * ISO 3166-1 alpha-2 country code of the feature\n   */\n  country_code: string;\n\n  /**\n   * (experimental) Kind of the feature\n   */\n  kind?:\n    | \"road\"\n    | \"road_relation\"\n    | \"admin_area\"\n    | \"place\"\n    | \"street\"\n    | \"virtual_street\";\n\n  /**\n   * (experimental) Value of place=* tag from OpenStreetMap feature if kind=place\n   */\n  \"osm:place_type\"?: string;\n\n  /**\n   * (experimental) Feature tags from OpenStreetMap. Only available for `poi` type.\n   */\n  \"osm:tags\"?: Record<string, string>;\n\n  /**\n   * Array of POI categories. Only available for `poi` type.\n   */\n  categories?: string[];\n};\n\ntype FeatureBase = {\n  /**\n   * Unique feature ID\n   */\n  id: string;\n\n  /**\n   * Localized feature name\n   */\n  text: string;\n\n  /**\n   * Query's primary ISO 639-1 language code\n   */\n  language?: string;\n\n  /**\n   * A string analogous to the `text` field that matches the query in the requested language.\n   * This field is only returned when multiple languages are requested using the `language` parameter, and will be present for each requested language.\n   */\n  [text: `text_${string}`]: string;\n\n  /**\n   * A ISO 639-1 query's fallback language code.\n   * This field is only returned when multiple languages are requested using the `language` parameter, and will be present for each requested language.\n   */\n  [language: `language_${string}`]: string;\n};\n\nexport type FeatureHierarchy = FeatureProperties & FeatureBase;\n\nexport type GeocodingFeature = Feature<Geometry, FeatureProperties> &\n  FeatureBase & {\n    /**\n     * Bounding box of the original feature as [w, s, e, n] array\n     */\n    bbox: BBox;\n\n    /**\n     * A [lon, lat] array of the original feature centeroid\n     */\n    center: Coordinates;\n\n    /**\n     * Formatted (including the hierarchy) and localized feature full name\n     */\n    place_name: string;\n\n    /**\n     * A string analogous to the `place_name` field that matches the query in the requested language.\n     * This field is only returned when multiple languages are requested using the `language` parameter, and will be present for each requested language.\n     */\n    [key: `place_name_${string}`]: string;\n\n    /**\n     * An array of feature types describing the feature.\n     * Currently each feature has only single type but this may change in the future.\n     */\n    place_type: string[];\n\n    /**\n     * Localized type of the place name, matches `place_type` property\n     */\n    place_type_name: string[];\n\n    /**\n     * Feature hierarchy\n     */\n    context?: Array<FeatureHierarchy>;\n\n    /**\n     * Address number, if applicable\n     */\n    address?: string;\n\n    /**\n     * Indicates how well the returned feature matches the user's query on a scale from 0 to 1.\n     * 0 means the result does not match the query text at all, while 1 means the result fully matches the query text.\n     * You can use the relevance property to remove results that don't fully match the query.\n     */\n    relevance: number;\n  };\n\nexport type GeocodingSearchResult = {\n  type: \"FeatureCollection\";\n\n  /**\n   * Array of features found\n   */\n  features: Array<GeocodingFeature>;\n\n  /**\n   * Tokenized search query\n   */\n  query: Array<string>;\n\n  /**\n   * Attribution of the result\n   */\n  attribution: string;\n};\n\nfunction addLanguageGeocodingOptions(\n  searchParams: URLSearchParams,\n  options: LanguageGeocodingOptions\n) {\n  if (options.language == undefined) {\n    return;\n  }\n\n  const languages = Array.from(\n    new Set(\n      (Array.isArray(options.language)\n        ? options.language\n        : [options.language]\n      ).map((lang) =>\n        lang === LanguageGeocoding.AUTO ? getAutoLanguageGeocoding() : lang\n      )\n    )\n  ).join(\",\");\n\n  searchParams.set(\"language\", languages);\n}\n\nfunction addCommonForwardAndReverseGeocodingOptions(\n  searchParams: URLSearchParams,\n  options: CommonForwardAndReverseGeocodingOptions\n) {\n  searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n\n  if (options.limit != undefined) {\n    searchParams.set(\"limit\", String(options.limit));\n  }\n\n  if (options.types != undefined) {\n    searchParams.set(\"types\", options.types.join(\",\"));\n  }\n\n  addLanguageGeocodingOptions(searchParams, options);\n}\n\nfunction addForwardGeocodingOptions(\n  searchParams: URLSearchParams,\n  options: GeocodingOptions\n) {\n  addCommonForwardAndReverseGeocodingOptions(searchParams, options);\n\n  if (options.bbox != undefined) {\n    searchParams.set(\"bbox\", options.bbox.join(\",\"));\n  }\n\n  if (options.proximity != undefined) {\n    searchParams.set(\"proximity\", options.proximity.join(\",\"));\n  }\n\n  if (options.country != undefined) {\n    searchParams.set(\"country\", options.country.join(\",\"));\n  }\n\n  if (options.fuzzyMatch != undefined) {\n    searchParams.set(\"fuzzyMatch\", options.fuzzyMatch ? \"true\" : \"false\");\n  }\n\n  if (options.autocomplete != undefined) {\n    searchParams.set(\"autocomplete\", options.autocomplete ? \"true\" : \"false\");\n  }\n}\n\n/**\n * Performs a forward geocoding query to MapTiler API.\n * Providing a human readable place name (of a city, country, street, etc.), the function returns\n * a list of candidate locations including longitude and latitude.\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/geocoding/#search-by-name-forward\n * @param query\n * @param options\n * @returns\n */\nasync function forward(\n  query: string,\n  options: GeocodingOptions = {}\n): Promise<GeocodingSearchResult> {\n  if (typeof query !== \"string\" || query.trim().length === 0) {\n    throw new Error(\"The query must be a non-empty string\");\n  }\n\n  const endpoint = new URL(\n    `geocoding/${encodeURIComponent(query)}.json`,\n    defaults.maptilerApiURL\n  );\n\n  const { searchParams } = endpoint;\n\n  addForwardGeocodingOptions(searchParams, options);\n\n  const urlWithParams = endpoint.toString();\n\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(res, customMessages[res.status] ?? \"\");\n  }\n\n  const obj: GeocodingSearchResult = await res.json();\n\n  return obj;\n}\n\n/**\n * Perform a reverse geocoding query to MapTiler API.\n * Providing a longitude and latitude, this function returns a set of human readable information about this place (country, city, street, etc.)\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/geocoding/#search-by-coordinates-reverse\n * @param position\n * @param options\n * @returns\n */\nasync function reverse(\n  position: Position,\n  options: ReverseGeocodingOptions = {}\n): Promise<GeocodingSearchResult> {\n  if (!Array.isArray(position) || position.length < 2) {\n    throw new Error(\"The position must be an array of form [lng, lat].\");\n  }\n\n  const endpoint = new URL(\n    `geocoding/${position[0]},${position[1]}.json`,\n    defaults.maptilerApiURL\n  );\n\n  addCommonForwardAndReverseGeocodingOptions(endpoint.searchParams, options);\n\n  const urlWithParams = endpoint.toString();\n\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(res, customMessages[res.status] ?? \"\");\n  }\n\n  const obj: GeocodingSearchResult = await res.json();\n\n  return obj;\n}\n\n/**\n * Perform a geocoding query to MapTiler API to obtain fature by its ID.\n * Providing a feature ID, this function returns a feature which includes its full geometry.\n * Note that the feature ID is not stable and it changes when the database is re-indexed.\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/geocoding/#search-by-feature-id\n * @param id\n * @param options\n * @returns\n */\nasync function byId(\n  id: string,\n  options: ByIdGeocodingOptions = {}\n): Promise<GeocodingSearchResult> {\n  const endpoint = new URL(`geocoding/${id}.json`, defaults.maptilerApiURL);\n\n  addLanguageGeocodingOptions(endpoint.searchParams, options);\n\n  const urlWithParams = endpoint.toString();\n\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(res, customMessages[res.status] ?? \"\");\n  }\n\n  const obj: GeocodingSearchResult = await res.json();\n\n  return obj;\n}\n\n/**\n * Perform a batch geocoding query to MapTiler API.\n * Provide multiple queries in the array. Each query can be forward, reverse or by feature ID.\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/geocoding/#batch-geocoding\n * @param queries\n * @param options\n * @returns\n */\nasync function batch(\n  queries: string[],\n  options: GeocodingOptions = {}\n): Promise<GeocodingSearchResult[]> {\n  if (!queries.length) {\n    return [];\n  }\n\n  const joinedQuery = queries\n    .map((query) => encodeURIComponent(query))\n    .join(\";\");\n\n  const endpoint = new URL(\n    `geocoding/${joinedQuery}.json`,\n    defaults.maptilerApiURL\n  );\n\n  const { searchParams } = endpoint;\n\n  addForwardGeocodingOptions(searchParams, options);\n\n  const urlWithParams = endpoint.toString();\n\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(res, customMessages[res.status] ?? \"\");\n  }\n\n  const obj = await res.json();\n\n  return queries.length === 1 ? [obj] : obj;\n}\n\n/**\n * The **geocoding** namespace contains asynchronous functions to call the [MapTiler Geocoding API](https://docs.maptiler.com/cloud/api/geocoding/).\n * The **Geocoding API** provides ways to get geographic coordinates from a human-readable search query of a place (forward geocoding)\n * and to get the location details (country, city, street, etc.) from a geographic coordinate (reverse geocoding);\n */\nconst geocoding = {\n  forward,\n  reverse,\n  byId,\n  batch,\n  language: LanguageGeocoding,\n};\n\nexport { geocoding };\n","import { BBox } from \"geojson\";\nimport { callFetch } from \"../callFetch\";\nimport { config } from \"../config\";\nimport { defaults } from \"../defaults\";\nimport { ServiceError } from \"./ServiceError\";\n\nconst customMessages = {\n  403: \"Key is missing, invalid or restricted\",\n};\n\n/**\n * Options that can be provided to get user data.\n */\nexport type GeolocationInfoOptions = {\n  /**\n   * Custom MapTiler Cloud API key to use instead of the one in global `config`\n   */\n  apiKey?: string;\n};\n\nexport type GeolocationResult = {\n  /**\n   * Name of the country\n   * Example: Switzerland\n   */\n  country?: string;\n\n  /**\n   * Two-letter code of the country ISO 3166-1 alpha-2 codes\n   * Example: CH\n   */\n  country_code?: string;\n\n  /**\n   * Bounds of the country in WGS84 degrees [west, south, east, north].\n   * Example: [5.95538,45.818852,10.490936,47.809357]\n   */\n  country_bounds?: BBox;\n\n  /**\n   * Official country languages in ISO 639-1 format. ISO 639-1 codes\n   * Example: [\"de\",\"fr\",\"it\"]\n   */\n  country_languages?: Array<string>;\n\n  /**\n   * Name of the continent\n   * Example: Europe\n   */\n  continent?: string;\n\n  /**\n   * Two-letter code of the continent\n   * Example: EU\n   */\n  continent_code?: string;\n\n  /**\n   * Indicated whether the country is part of the European Union.\n   */\n  eu?: boolean;\n\n  /**\n   * Name of the city\n   * Example: Zurich\n   */\n  city?: string;\n\n  /**\n   * Latitude of the location\n   * Example: 47.36667\n   */\n  latitude?: number;\n\n  /**\n   * Longitude of the location\n   * Example: 8.55\n   */\n  longitude?: number;\n\n  /**\n   * Postal code\n   * Example: 8000\n   */\n  postal?: string;\n\n  /**\n   * If known, the ISO 3166-2 name for the first level region. ISO 3166-2 codes\n   * Example: Zurich\n   */\n  region?: string;\n\n  /**\n   * If known, the ISO 3166-2 code for the first level region. ISO 3166-2 codes\n   * Example: ZH\n   */\n  region_code?: string;\n\n  /**\n   * Name of the timezone\n   * Example: Europe/Zurich\n   */\n  timezone?: string;\n};\n\n/**\n * Looks up geolocation details from IP address using MapTiler API.\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/geolocation/#ip-geolocation\n * @returns\n */\nasync function info(\n  options: GeolocationInfoOptions = {}\n): Promise<GeolocationResult> {\n  const endpoint = new URL(`geolocation/ip.json`, defaults.maptilerApiURL);\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  const urlWithParams = endpoint.toString();\n\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages ? customMessages[res.status] : \"\"\n    );\n  }\n\n  const obj = await res.json();\n  return obj as GeolocationResult;\n}\n\n/**\n * The **geolocation** namespace contains an asynchronous function to call the [MapTiler Geolocation API](https://docs.maptiler.com/cloud/api/geolocation/).\n * The **Geolocation API** provides a way to retrieve the IP address as well as geographic informations of a machine performing the query (most likely: a user)\n */\nconst geolocation = {\n  info,\n};\n\nexport { geolocation };\n","import { BBox, Position } from \"geojson\";\nimport { callFetch } from \"../callFetch\";\nimport { config } from \"../config\";\nimport { defaults } from \"../defaults\";\nimport { ServiceError } from \"./ServiceError\";\n\nconst customMessages = {\n  403: \"Key is missing, invalid or restricted\",\n};\n\nexport type CoordinatesSearchOptions = {\n  /**\n   * Custom MapTiler Cloud API key to use instead of the one in global `config`\n   */\n  apiKey?: string;\n\n  /**\n   * Maximum number of results returned (default: 10)\n   */\n  limit?: number;\n\n  /**\n   *  Show detailed transformations for each CRS (default: false)\n   */\n  transformations?: boolean;\n\n  /**\n   * Show exports in WKT and Proj4 notations (default: false)\n   */\n  exports?: boolean;\n};\n\nexport type CoordinateId = {\n  authority: string;\n  code: BigInteger;\n};\n\nexport type CoordinateExport = {\n  proj4: string;\n  wkt: string;\n};\n\nexport type CoordinateGrid = {\n  path: string;\n};\n\nexport type CoordinateTransformation = {\n  id: CoordinateId;\n  name: string;\n  reversible: boolean;\n  usable: boolean;\n  deprecated: boolean;\n  grids: Array<CoordinateGrid>;\n  accuracy?: number;\n  area?: string;\n  bbox?: BBox;\n  target_crs?: CoordinateId;\n  unit?: string;\n};\n\nexport type CoordinateSearch = {\n  id: CoordinateId;\n\n  name: string;\n\n  kind: string;\n\n  deprecated: boolean;\n\n  transformations?: Array<CoordinateTransformation | number>;\n\n  accuracy?: number;\n\n  unit?: string;\n\n  area?: string;\n\n  /**\n   * Bounding box of the resource in [min_lon, min_lat, max_lon, max_lat] order.\n   */\n  bbox?: BBox;\n\n  /**\n   * Most suitable transformation for this CRS.\n   */\n  default_transformation?: any;\n\n  exports: CoordinateExport;\n};\n\nexport type CoordinateSearchResult = {\n  /**\n   * The coordinate search results\n   */\n  results: Array<CoordinateSearch>;\n\n  /**\n   * The number of results\n   */\n  total: number;\n};\n\n/**\n * Search information about coordinate systems using MapTiler API.\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/coordinates/#search-coordinate-systems\n * @param query Can be any kind of CRS by name or code\n * @param options\n * @returns\n */\nasync function search(\n  query: string,\n  options: CoordinatesSearchOptions = {}\n): Promise<CoordinateSearchResult> {\n  if (typeof query !== \"string\" || query.trim().length === 0) {\n    throw new Error(\"The query must be a non-empty string\");\n  }\n\n  const endpoint = new URL(\n    `coordinates/search/${query}.json`,\n    defaults.maptilerApiURL\n  );\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n\n  if (\"limit\" in options) {\n    endpoint.searchParams.set(\"limit\", options.limit.toString());\n  }\n\n  if (\"transformations\" in options) {\n    endpoint.searchParams.set(\n      \"transformations\",\n      options.transformations.toString()\n    );\n  }\n\n  if (\"exports\" in options) {\n    endpoint.searchParams.set(\"exports\", options.exports.toString());\n  }\n\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages ? customMessages[res.status] : \"\"\n    );\n  }\n\n  const obj = await res.json();\n  return obj as CoordinateSearchResult;\n}\n\nexport type XYZ = {\n  x?: number;\n  y?: number;\n  z?: number;\n};\n\nexport type CoordinateTransformResult = {\n  results: Array<XYZ>;\n\n  /**\n   * Transformations are selected using given ops parameter.\n   * If no parameter is given, auto strategy is used.\n   * If given, it may try to use a listed transformation,\n   * then fallback to towgs84 patching, and finally boundcrs.\n   */\n  transformer_selection_strategy: string;\n};\n\n/**\n * Options that can be provided when transforming a coordinate from one CRS to another.\n */\nexport type CoordinatesTransformOptions = {\n  /**\n   * Custom MapTiler Cloud API key to use instead of the one in global `config`\n   */\n  apiKey?: string;\n\n  /**\n   * Source coordinate reference system (default: 4326)\n   */\n  sourceCrs?: number;\n\n  /**\n   * Target coordinate reference system (default: 4326)\n   */\n  targetCrs?: number;\n\n  /**\n   * List of codes of operations\n   */\n  operations?: number | Array<number>;\n};\n\n/**\n * Transforms coordinates from a source reference system to a target reference system using MapTiler API.\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/coordinates/#transform-coordinates\n * @param positions\n * @param options\n * @returns\n */\nasync function transform(\n  positions: Position | Array<Position>,\n  options: CoordinatesTransformOptions = {}\n): Promise<CoordinateTransformResult> {\n  const coordinatesStr = (Array.isArray(positions[0]) ? positions : [positions])\n    .map((coord) => `${coord[0]},${coord[1]}`)\n    .join(\";\");\n\n  const endpoint = new URL(\n    `coordinates/transform/${coordinatesStr}.json`,\n    defaults.maptilerApiURL\n  );\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n\n  if (\"sourceCrs\" in options) {\n    endpoint.searchParams.set(\"s_srs\", options.sourceCrs.toString());\n  }\n\n  if (\"targetCrs\" in options) {\n    endpoint.searchParams.set(\"t_srs\", options.targetCrs.toString());\n  }\n\n  if (\"operations\" in options) {\n    endpoint.searchParams.set(\n      \"ops\",\n      (Array.isArray(options.operations)\n        ? options.operations\n        : [options.operations]\n      ).join(\"|\")\n    );\n  }\n\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages ? customMessages[res.status] : \"\"\n    );\n  }\n\n  const obj = await res.json();\n  return obj as CoordinateTransformResult;\n}\n\n/**\n * The **coordinate** namespace contains asynchronous functions to call the [MapTiler Coordinate API](https://docs.maptiler.com/cloud/api/coordinates/).\n * The goal of the **Coordinate API* is query information about spatial coordinate reference system (CRS) as well as to transform coordinates from one CRS to another.\n */\nconst coordinates = {\n  search,\n  transform,\n};\n\nexport { coordinates };\n","import { FeatureCollection } from \"geojson\";\nimport { callFetch } from \"../callFetch\";\nimport { config } from \"../config\";\nimport { defaults } from \"../defaults\";\nimport { ServiceError } from \"./ServiceError\";\n\nconst customMessages = {\n  403: \"Key is missing, invalid or restricted\",\n};\n\n/**\n * Options that can be provided to get user data.\n */\nexport type GetDataOptions = {\n  /**\n   * Custom MapTiler Cloud API key to use instead of the one in global `config`\n   */\n  apiKey?: string;\n};\n\n/**\n * Get user data and returns it as GeoJSON using the MapTiler API.\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/data/#geojson\n * @param dataId\n * @returns\n */\nasync function get(\n  dataId: string,\n  options: GetDataOptions = {}\n): Promise<FeatureCollection> {\n  if (typeof dataId !== \"string\" || dataId.trim().length === 0) {\n    throw new Error(\"The data ID must be a non-empty string\");\n  }\n\n  const endpoint = new URL(\n    `data/${encodeURIComponent(dataId)}/features.json`,\n    defaults.maptilerApiURL\n  );\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n  const urlWithParams = endpoint.toString();\n\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages ? customMessages[res.status] : \"\"\n    );\n  }\n\n  const obj = await res.json();\n  return obj;\n}\n\n/**\n * The **data** namespace contains an asynchronous function to call the [MapTiler Data API](https://docs.maptiler.com/cloud/api/data/).\n * The **Data API** provides a way to retrieve user data in GeoJSON format.\n */\nconst data = {\n  get,\n};\n\nexport { data };\n","/**\n * Expand the map style provided as argument of the Map constructor\n * @param style\n * @returns\n */\nexport function expandMapStyle(style): string {\n  // testing if the style provided is of form \"maptiler://some-style\"\n  const maptilerDomainRegex = /^maptiler:\\/\\/(.*)/;\n  let match;\n  const trimmed = style.trim();\n  let expandedStyle;\n\n  // The style was possibly already given as expanded URL\n  if (trimmed.startsWith(\"http://\") || trimmed.startsWith(\"https://\")) {\n    expandedStyle = trimmed;\n  } else if ((match = maptilerDomainRegex.exec(trimmed)) !== null) {\n    expandedStyle = `https://api.maptiler.com/maps/${match[1]}/style.json`;\n  } else {\n    // The style could also possibly just be the name of the style without any URI style\n    expandedStyle = `https://api.maptiler.com/maps/${trimmed}/style.json`;\n  }\n\n  return expandedStyle;\n}\n\n/**\n * Type for object containing style details\n */\nexport type MapStylePreset = {\n  referenceStyleID: string;\n  name: string;\n  description: string;\n  variants: Array<{\n    id: string;\n    name: string;\n    variantType: string;\n    description: string;\n    imageURL: string;\n  }>;\n};\n\n/**\n * An instance of MapStyleVariant contains information about a style to use that belong to a reference style\n */\nexport class MapStyleVariant {\n  constructor(\n    /**\n     * Human-friendly name\n     */\n    private name: string,\n\n    /**\n     * Variant name the variant is addressed to from its reference style: `MapStyle.REFERNCE_STYLE_NAME.VARIANT_TYPE`\n     */\n    private variantType: string,\n\n    /**\n     * MapTiler Cloud id\n     */\n    private id: string,\n\n    /**\n     * Reference map style, used to retrieve sibling variants\n     */\n    private referenceStyle: ReferenceMapStyle,\n\n    /**\n     * Human-friendly description\n     */\n    private description: string,\n\n    /**\n     * URL to an image describing the style variant\n     */\n    private imageURL: string\n  ) {}\n\n  /**\n   * Get the human-friendly name\n   * @returns\n   */\n  getName(): string {\n    return this.name;\n  }\n\n  getFullName(): string {\n    return `${this.referenceStyle.getName()} ${this.name}`;\n  }\n\n  /**\n   * Get the variant type (eg. \"DEFAULT\", \"DARK\", \"PASTEL\", etc.)\n   * @returns\n   */\n  getType(): string {\n    return this.variantType;\n  }\n\n  /**\n   * Get the MapTiler Cloud id\n   * @returns\n   */\n  getId(): string {\n    return this.id;\n  }\n\n  /**\n   * Get the human-friendly description\n   */\n  getDescription(): string {\n    return this.description;\n  }\n\n  /**\n   * Get the reference style this variant belongs to\n   * @returns\n   */\n  getReferenceStyle(): ReferenceMapStyle {\n    return this.referenceStyle;\n  }\n\n  /**\n   * Check if a variant of a given type exists for _this_ variants\n   * (eg. if this is a \"DARK\", then we can check if there is a \"LIGHT\" variant of it)\n   * @param variantType\n   * @returns\n   */\n  hasVariant(variantType: string): boolean {\n    return this.referenceStyle.hasVariant(variantType);\n  }\n\n  /**\n   * Retrieve the variant of a given type. If not found, will return the \"DEFAULT\" variant.\n   * (eg. _this_ \"DARK\" variant does not have any \"PASTEL\" variant, then the \"DEFAULT\" is returned)\n   * @param variantType\n   * @returns\n   */\n  getVariant(variantType: string): MapStyleVariant {\n    return this.referenceStyle.getVariant(variantType);\n  }\n\n  /**\n   * Get all the variants for _this_ variants, except _this_ current one\n   * @returns\n   */\n  getVariants(): Array<MapStyleVariant> {\n    return this.referenceStyle.getVariants().filter((v) => v !== this);\n  }\n\n  /**\n   * Get the image URL that represent _this_ variant\n   * @returns\n   */\n  getImageURL(): string {\n    return this.imageURL;\n  }\n\n  /**\n   * Get the style as usable by MapLibre, a string (URL) or a plain style description (StyleSpecification)\n   * @returns\n   */\n  getExpandedStyleURL(): string {\n    return expandMapStyle(this.getId());\n  }\n}\n\n/**\n * An instance of reference style contains a list of StyleVariants ordered by relevance\n */\nexport class ReferenceMapStyle {\n  /**\n   * Variants that belong to this reference style, key being the reference type\n   */\n  private variants: { [key: string]: MapStyleVariant } = {};\n\n  /**\n   * Variants that belong to this reference style, ordered by relevance\n   */\n  private orderedVariants: Array<MapStyleVariant> = [];\n\n  constructor(\n    /**\n     * Human-friendly name of this reference style\n     */\n    private name: string,\n\n    /**\n     * ID of this reference style\n     */\n    private id: string\n  ) {}\n\n  /**\n   * Get the human-friendly name of this reference style\n   * @returns\n   */\n  getName(): string {\n    return this.name;\n  }\n\n  /**\n   * Get the id of _this_ reference style\n   * @returns\n   */\n  getId(): string {\n    return this.id;\n  }\n\n  /**\n   * Add a variant to _this_ reference style\n   * @param v\n   */\n  addVariant(v: MapStyleVariant) {\n    this.variants[v.getType()] = v;\n    this.orderedVariants.push(v);\n  }\n\n  /**\n   * Check if a given variant type exists for this reference style\n   * @param variantType\n   * @returns\n   */\n  hasVariant(variantType: string): boolean {\n    return variantType in this.variants;\n  }\n\n  /**\n   * Get a given variant. If the given type of variant does not exist for this reference style,\n   * then the most relevant default variant is returned instead\n   * @param variantType\n   * @returns\n   */\n  getVariant(variantType: string): MapStyleVariant {\n    return variantType in this.variants\n      ? this.variants[variantType]\n      : this.orderedVariants[0];\n  }\n\n  /**\n   * Get the list of variants for this reference style\n   * @returns\n   */\n  getVariants(): Array<MapStyleVariant> {\n    return Object.values(this.variants);\n  }\n\n  /**\n   * Get the defualt variant for this reference style\n   * @returns\n   */\n  getDefaultVariant(): MapStyleVariant {\n    return this.orderedVariants[0];\n  }\n}\n\n/**\n * All the styles and variants maintained by MapTiler.\n */\nexport type MapStyleType = {\n  /**\n   * Suitable for navigation, with high level of detail on urban areas, plenty of POIs and 3D buildings\n   */\n  STREETS: ReferenceMapStyle & {\n    /**\n     * Suitable for navigation, with high level of detail on urban areas, plenty of POIs and 3D buildings.\n     */\n    DEFAULT: MapStyleVariant;\n    /**\n     * Suitable for navigation, with high level of detail on urban areas, plenty of POIs and 3D buildings, in dark mode.\n     */\n    DARK: MapStyleVariant;\n    /**\n     * Suitable for navigation, with high level of detail on urban areas, plenty of POIs and 3D buildings, in light mode.\n     */\n    LIGHT: MapStyleVariant;\n    /**\n     * Suitable for navigation, with high level of detail on urban areas, plenty of POIs and 3D buildings, in blue night mode.\n     */\n    NIGHT: MapStyleVariant;\n    /**\n     * Suitable for navigation, with high level of detail on urban areas, plenty of POIs and 3D buildings, with a pastel color palette.\n     */\n    PASTEL: MapStyleVariant;\n  };\n\n  /**\n   * Suitable for outdoor activities. With elevation isolines and hillshading.\n   */\n  OUTDOOR: ReferenceMapStyle & {\n    /**\n     * Suitable for outdoor activities. With elevation isolines and hillshading.\n     */\n    DEFAULT: MapStyleVariant;\n\n    /**\n     * Suitable for outdoor activities. With elevation isolines and hillshading, in dark mode.\n     */\n    DARK: MapStyleVariant;\n  };\n\n  /**\n   * Suitabe for winter outdoor activities. With ski tracks, elevation isolines and hillshading.\n   */\n  WINTER: ReferenceMapStyle & {\n    /**\n     * Suitabe for winter outdoor activities. With ski tracks, elevation isolines and hillshading.\n     */\n    DEFAULT: MapStyleVariant;\n    /**\n     * Suitabe for winter outdoor activities. With ski tracks, elevation isolines and hillshading, in dark mode.\n     */\n    DARK: MapStyleVariant;\n  };\n\n  /**\n   * High resolution imagery only, without any label.\n   */\n  SATELLITE: ReferenceMapStyle & {\n    /**\n     * High resolution imagery only, without any label.\n     */\n    DEFAULT: MapStyleVariant;\n  };\n\n  /**\n   * High resolution imagery with labels, political borders and roads.\n   */\n  HYBRID: ReferenceMapStyle & {\n    /**\n     * High resolution imagery with labels, political borders and roads.\n     */\n    DEFAULT: MapStyleVariant;\n  };\n\n  /**\n   * A minimalist street-oriented style without POI\n   */\n  BASIC: ReferenceMapStyle & {\n    /**\n     * A minimalist street-oriented style without POI\n     */\n    DEFAULT: MapStyleVariant;\n    /**\n     * A minimalist street-oriented style without POI, in dark mode\n     */\n    DARK: MapStyleVariant;\n    /**\n     * A minimalist street-oriented style without POI, in light mode\n     */\n    LIGHT: MapStyleVariant;\n  };\n\n  /**\n   * A bright street-oriented style, a nice alternative to `streets`\n   */\n  BRIGHT: ReferenceMapStyle & {\n    /**\n     * A bright street-oriented style, a nice alternative to `streets`\n     */\n    DEFAULT: MapStyleVariant;\n    /**\n     * A bright street-oriented style, a nice alternative to `streets`, in dark mode\n     */\n    DARK: MapStyleVariant;\n    /**\n     * A bright street-oriented style, a nice alternative to `streets`, in light mode\n     */\n    LIGHT: MapStyleVariant;\n    /**\n     * A bright street-oriented style, a nice alternative to `streets`, with a soft pastel color palette\n     */\n    PASTEL: MapStyleVariant;\n  };\n\n  /**\n   * Classic OpenStreetMap style\n   */\n  OPENSTREETMAP: ReferenceMapStyle & {\n    DEFAULT: MapStyleVariant;\n  };\n\n  /**\n   * A nice high-contrast, yet less saturated alternative to the `outdoor` style, with hillshading, 3D buildings and fairly high street details\n   */\n  TOPO: ReferenceMapStyle & {\n    /**\n     * A nice high-contrast, yet less saturated alternative to the `outdoor` style, with hillshading, 3D buildings and fairly high street details\n     */\n    DEFAULT: MapStyleVariant;\n    /**\n     * A nice high-contrast, yet less saturated alternative to the `outdoor` style, with hillshading, 3D buildings and fairly high street details, in dark mode\n     */\n    DARK: MapStyleVariant;\n    /**\n     * A nice high-contrast, and high saturation alternative to the `outdoor` style, with hillshading, 3D buildings and fairly high street details\n     */\n    SHINY: MapStyleVariant;\n    /**\n     * A nice low-contrast, alternative to the `outdoor` style, with hillshading, 3D buildings and fairly high street details, using a soft pastel color palette\n     */\n    PASTEL: MapStyleVariant;\n\n    /**\n     * A nice very high-contrast, yet less saturated alternative to the `outdoor` style, with hillshading, 3D buildings and fairly high street details\n     */\n    TOPOGRAPHIQUE: MapStyleVariant;\n  };\n\n  /**\n   * A nice alternative to `streets` with a soft color palette\n   */\n  VOYAGER: ReferenceMapStyle & {\n    /**\n     * A nice alternative to `streets` with a soft color palette\n     */\n    DEFAULT: MapStyleVariant;\n    /**\n     * A nice alternative to `streets`, in very dark mode\n     */\n    DARK: MapStyleVariant;\n    /**\n     * A nice alternative to `streets`, in light mode\n     */\n    LIGHT: MapStyleVariant;\n    /**\n     * A nice alternative to `streets` with a soft sepia color palette and vintage look\n     */\n    VINTAGE: MapStyleVariant;\n  };\n\n  /**\n   * A bold very high contrast black and white (no gray!) style for the city\n   */\n  TONER: ReferenceMapStyle & {\n    /**\n     * A bold very high contrast black and white (no gray!) style for the city\n     */\n    DEFAULT: MapStyleVariant;\n    /**\n     * A bold very high contrast black and white (no gray!) style for the city, without any label\n     */\n    BACKGROUND: MapStyleVariant;\n    /**\n     * A bold very high contrast, yet faded, style for the city\n     */\n    LITE: MapStyleVariant;\n    /**\n     * A bold very high contrast black and white (no gray!) style for the city, with no building, only roads!\n     */\n    LINES: MapStyleVariant;\n  };\n\n  /**\n   * Minimalist style, perfect for data visualization\n   */\n  DATAVIZ: ReferenceMapStyle & {\n    /**\n     *  Minimalist style, perfect for data visualization\n     */\n    DEFAULT: MapStyleVariant;\n\n    /**\n     *  Minimalist style, perfect for data visualization in dark mode\n     */\n    DARK: MapStyleVariant;\n\n    /**\n     *  Minimalist style, perfect for data visualization in light mode\n     */\n    LIGHT: MapStyleVariant;\n  };\n\n  /**\n   * Explore deep see trenches and mountains, with isolines and depth labels\n   */\n  OCEAN: ReferenceMapStyle & {\n    /**\n     * Explore deep see trenches and mountains, with isolines and depth labels\n     */\n    DEFAULT: MapStyleVariant;\n  };\n\n  /**\n   * Neutral greyscale style with hillshading suitable for colorful terrain-aware visualization\n   */\n  BACKDROP: ReferenceMapStyle & {\n    /**\n     *  Neutral greyscale style with hillshading suitable for colorful terrain-aware visualization\n     */\n    DEFAULT: MapStyleVariant;\n\n    /**\n     *  Dark greyscale style with hillshading suitable for colorful terrain-aware visualization\n     */\n    DARK: MapStyleVariant;\n\n    /**\n     *  Light greyscale style with hillshading suitable for colorful terrain-aware visualization\n     */\n    LIGHT: MapStyleVariant;\n  };\n};\n\nexport const mapStylePresetList: Array<MapStylePreset> = [\n  {\n    referenceStyleID: \"STREETS\",\n    name: \"Streets\",\n    description: \"\",\n    variants: [\n      {\n        id: \"streets-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"streets-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"streets-v2-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"streets-v2-night\",\n        name: \"Night\",\n        variantType: \"NIGHT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"streets-v2-pastel\",\n        name: \"Pastel\",\n        variantType: \"PASTEL\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"OUTDOOR\",\n    name: \"Outdoor\",\n    description: \"\",\n    variants: [\n      {\n        id: \"outdoor-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"outdoor-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"WINTER\",\n    name: \"Winter\",\n    description: \"\",\n    variants: [\n      {\n        id: \"winter-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"winter-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"SATELLITE\",\n    name: \"Satellite\",\n    description: \"\",\n    variants: [\n      {\n        id: \"satellite\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"HYBRID\",\n    name: \"Hybrid\",\n    description: \"\",\n    variants: [\n      {\n        id: \"hybrid\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"BASIC\",\n    name: \"Basic\",\n    description: \"\",\n    variants: [\n      {\n        id: \"basic-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"basic-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"basic-v2-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"BRIGHT\",\n    name: \"Bright\",\n    description: \"\",\n    variants: [\n      {\n        id: \"bright-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"bright-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"bright-v2-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"bright-v2-pastel\",\n        name: \"Pastel\",\n        variantType: \"PASTEL\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"OPENSTREETMAP\",\n    name: \"OpenStreetMap\",\n    description: \"\",\n    variants: [\n      {\n        id: \"openstreetmap\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"TOPO\",\n    name: \"Topo\",\n    description: \"\",\n    variants: [\n      {\n        id: \"topo-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"topo-v2-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"topo-v2-shiny\",\n        name: \"Shiny\",\n        variantType: \"SHINY\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"topo-v2-pastel\",\n        name: \"Pastel\",\n        variantType: \"PASTEL\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"topo-v2-topographique\",\n        name: \"Topographique\",\n        variantType: \"TOPOGRAPHIQUE\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"VOYAGER\",\n    name: \"Voyager\",\n    description: \"\",\n    variants: [\n      {\n        id: \"voyager-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"voyager-v2-darkmatter\",\n        name: \"Darkmatter\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"voyager-v2-positron\",\n        name: \"Positron\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"voyager-v2-vintage\",\n        name: \"Vintage\",\n        variantType: \"VINTAGE\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"TONER\",\n    name: \"Toner\",\n    description: \"\",\n    variants: [\n      {\n        id: \"toner-v2\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"toner-v2-background\",\n        name: \"Background\",\n        variantType: \"BACKGROUND\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"toner-v2-lite\",\n        name: \"Lite\",\n        variantType: \"LITE\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"toner-v2-lines\",\n        name: \"Lines\",\n        variantType: \"LINES\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"DATAVIZ\",\n    name: \"Dataviz\",\n    description: \"\",\n    variants: [\n      {\n        id: \"dataviz\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"dataviz-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"dataviz-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"BACKDROP\",\n    name: \"Backdrop\",\n    description: \"\",\n    variants: [\n      {\n        id: \"backdrop\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"backdrop-dark\",\n        name: \"Dark\",\n        variantType: \"DARK\",\n        description: \"\",\n        imageURL: \"\",\n      },\n      {\n        id: \"backdrop-light\",\n        name: \"Light\",\n        variantType: \"LIGHT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n\n  {\n    referenceStyleID: \"OCEAN\",\n    name: \"Ocean\",\n    description: \"\",\n    variants: [\n      {\n        id: \"ocean\",\n        name: \"Default\",\n        variantType: \"DEFAULT\",\n        description: \"\",\n        imageURL: \"\",\n      },\n    ],\n  },\n];\n\nfunction makeReferenceStyleProxy(referenceStyle: ReferenceMapStyle) {\n  return new Proxy(referenceStyle, {\n    get(target, prop, receiver) {\n      if (target.hasVariant(prop as string)) {\n        return target.getVariant(prop as string);\n      }\n\n      // This variant does not exist for this style, but since it's full uppercase\n      // we guess that the dev tries to access a style variant. So instead of\n      // returning the default (STREETS.DEFAULT), we return the non-variant of the current style\n      if (prop.toString().toUpperCase() === (prop as string)) {\n        return referenceStyle.getDefaultVariant();\n      }\n\n      return Reflect.get(target, prop, receiver);\n    },\n  });\n}\n\nfunction buildMapStyles(): MapStyleType {\n  const mapStyle = {};\n\n  for (let i = 0; i < mapStylePresetList.length; i += 1) {\n    const refStyleInfo = mapStylePresetList[i];\n\n    const refStyle = makeReferenceStyleProxy(\n      new ReferenceMapStyle(refStyleInfo.name, refStyleInfo.referenceStyleID)\n    );\n\n    for (let j = 0; j < refStyleInfo.variants.length; j += 1) {\n      const variantInfo = refStyleInfo.variants[j];\n      const variant = new MapStyleVariant(\n        variantInfo.name, // name\n        variantInfo.variantType, // variantType\n        variantInfo.id, // id\n        refStyle, // referenceStyle\n        variantInfo.description,\n        variantInfo.imageURL // imageURL\n      );\n\n      refStyle.addVariant(variant);\n    }\n    mapStyle[refStyleInfo.referenceStyleID] = refStyle;\n  }\n  return mapStyle as MapStyleType;\n}\n\nexport function styleToStyle(\n  style: string | ReferenceMapStyle | MapStyleVariant | null | undefined\n): string {\n  if (!style) {\n    return MapStyle[mapStylePresetList[0].referenceStyleID]\n      .getDefaultVariant()\n      .getId();\n  }\n\n  // If the provided style is a shorthand (eg. \"streets-v2\") then we make sure it's trimmed and lowercase\n  if (typeof style === \"string\" || style instanceof String) {\n    return style.trim().toLowerCase();\n  }\n\n  if (style instanceof MapStyleVariant) {\n    return style.getId();\n  }\n\n  if (style instanceof ReferenceMapStyle) {\n    return style.getDefaultVariant().getId();\n  }\n}\n\n/**\n * Contains all the reference map style created by MapTiler team as well as all the variants.\n * For example, `MapStyle.STREETS` and the variants:\n * - `MapStyle.STREETS.DARK`\n * - `MapStyle.STREETS.LIGHT`\n * - `MapStyle.STREETS.PASTEL`\n *\n */\nexport const MapStyle: MapStyleType = buildMapStyles();\n","/**\\\n * This code is borrowed from https://github.com/mourner/simplify-js and reworked a little.\n */\n\nimport { Position } from \"geojson\";\n\n// square distance from a point to a segment\nfunction getSqSegDist(p: Position, p1: Position, p2: Position): number {\n  let x = p1[0],\n    y = p1[1],\n    dx = p2[0] - x,\n    dy = p2[1] - y;\n\n  if (dx !== 0 || dy !== 0) {\n    const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n\n    if (t > 1) {\n      x = p2[0];\n      y = p2[1];\n    } else if (t > 0) {\n      x += dx * t;\n      y += dy * t;\n    }\n  }\n\n  dx = p[0] - x;\n  dy = p[1] - y;\n\n  return dx * dx + dy * dy;\n}\n\nfunction simplifyDPStep(\n  points: Array<Position>,\n  first: number,\n  last: number,\n  sqTolerance: number,\n  simplified: Array<Position>\n) {\n  let maxSqDist = sqTolerance,\n    index;\n\n  for (let i = first + 1; i < last; i++) {\n    const sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n    if (sqDist > maxSqDist) {\n      index = i;\n      maxSqDist = sqDist;\n    }\n  }\n\n  if (maxSqDist > sqTolerance) {\n    if (index - first > 1) {\n      simplifyDPStep(points, first, index, sqTolerance, simplified);\n    }\n    simplified.push(points[index]);\n\n    if (last - index > 1) {\n      simplifyDPStep(points, index, last, sqTolerance, simplified);\n    }\n  }\n}\n\n// simplification using Ramer-Douglas-Peucker algorithm\nfunction simplifyDouglasPeucker(\n  points: Array<Position>,\n  sqTolerance: number\n): Array<Position> {\n  const last = points.length - 1;\n  const simplified = [points[0]];\n  simplifyDPStep(points, 0, last, sqTolerance, simplified);\n  simplified.push(points[last]);\n  return simplified;\n}\n\n// both algorithms combined for awesome performance\nexport default function simplify(\n  points: Array<Position>,\n  tolerance: number\n): Array<Position> {\n  if (points.length <= 2) {\n    return points;\n  }\n\n  const sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n  const simplePoints = simplifyDouglasPeucker(points, sqTolerance);\n  return simplePoints;\n}\n","import { BBox, Position } from \"geojson\";\nimport { config } from \"../config\";\nimport { defaults } from \"../defaults\";\nimport { MapStyleVariant, ReferenceMapStyle, styleToStyle } from \"../mapstyle\";\nimport simplify from \"./simplify\";\n\n/**\n * Base set of options that can be provided to all the types of static maps\n */\nexport type StaticMapBaseOptions = {\n  /**\n   * Custom MapTiler Cloud API key to use instead of the one in global `config`\n   */\n  apiKey?: string;\n\n  /**\n   * Style of the map (not full style URL). Example: \"winter\", \"streets-v2\".\n   * Default: `\"streets-v2\"`\n   */\n  style?: string | ReferenceMapStyle | MapStyleVariant;\n\n  /**\n   * Double the size of the static map image to support hiDPI/Retina monitors.\n   * Default: `false`\n   */\n  hiDPI?: boolean;\n\n  /**\n   * Image format.\n   * Default: `\"png\"`\n   */\n  format?: \"png\" | \"jpg\" | \"webp\";\n\n  /**\n   * Width of the output image. Maximum value: `2048`.\n   * Default: `1024`\n   */\n  width?: number;\n\n  /**\n   * Height of the output image. Maximum value: `2048`.\n   * Default: `1024`\n   */\n  height?: number;\n\n  /**\n   * Placement of the attribution. Can also be set to `false` to not show attribution.\n   * Default: `\"bottomright\"`\n   */\n  attribution?: \"bottomright\" | \"bottomleft\" | \"topleft\" | \"topright\" | false;\n\n  /**\n   * A marker or list of markers to show on the map\n   * Default: none provided\n   */\n  markers?: StaticMapMarker | Array<StaticMapMarker>;\n\n  /**\n   * URL of the marker image. Applies only if one or multiple markers positions are provided.\n   * Default: none provided\n   */\n  markerIcon?: string;\n\n  /**\n   * Position of the marker regarding its coordinates. Applies only:\n   * - with a custom icon provided with `markerIcon`\n   * - if one or multiple markers positions are provided.\n   * Default: `\"bottom\"`\n   */\n  markerAnchor?:\n    | \"top\"\n    | \"left\"\n    | \"bottom\"\n    | \"right\"\n    | \"center\"\n    | \"topleft\"\n    | \"bottomleft\"\n    | \"topright\"\n    | \"bottomright\";\n\n  /**\n   * Draw a path or polygon on top of the map. If the path is too long it will be simplified, yet remaining accurate.\n   * Default: none provided\n   */\n  path?: Array<Position>;\n\n  /**\n   * Color of the path line. The color must be CSS compatible.\n   * Examples:\n   * - long form hex without transparency `\"#FF0000\"` (red)\n   * - short form hex without transparency `\"#F00\"` (red)\n   * - long form hex with transparency `\"#FF000008\"` (red, half opacity)\n   * - short form hex with transparency `\"#F008\"` (red, half opacity)\n   * - CSS color shorthands: `\"red\"`, `\"chartreuse\"`, etc.\n   * - decimal RGB values without transparency: `\"rgb(128, 100, 255)\"`\n   * - decimal RGB values with transparency: `\"rgb(128, 100, 255, 0.5)\"`\n   * Default: `\"blue\"`\n   */\n  pathStrokeColor?: string;\n\n  /**\n   * Color of the filling, also works if the polygon is not closed. The color must be CSS compatible.\n   * Examples:\n   * - long form hex without transparency `\"#FF0000\"` (red)\n   * - short form hex without transparency `\"#F00\"` (red)\n   * - long form hex with transparency `\"#FF000008\"` (red, half opacity)\n   * - short form hex with transparency `\"#F008\"` (red, half opacity)\n   * - CSS color shorthands: `\"red\"`, `\"chartreuse\"`, etc.\n   * - decimal RGB values without transparency: `\"rgb(128, 100, 255)\"`\n   * - decimal RGB values with transparency: `\"rgb(128, 100, 255, 0.5)\"`\n   * Default: none (transparent filling)\n   */\n  pathFillColor?: string;\n\n  /**\n   * Width of the path line in pixel. It can be floating point precision (ex: `0.5`)\n   * Default: `1` if `hiDPI` is `false` and `2` if `hiDPI` is `true`.\n   */\n  pathWidth?: number;\n};\n\n/**\n * Options that can be provided to centered static maps\n */\nexport type CenteredStaticMapOptions = StaticMapBaseOptions;\n\n/**\n * Options that can be provided to bounded static maps\n */\nexport type BoundedStaticMapOptions = StaticMapBaseOptions & {\n  /**\n   * Extra space added around the regio of interest, in percentage.\n   * Default: `0.1` (for 10%)\n   */\n  padding?: number;\n};\n\n/**\n * Options that can be provided to automatic static maps\n */\nexport type AutomaticStaticMapOptions = BoundedStaticMapOptions;\n\n/**\n * Definition of a maker to show on a static map\n */\nexport type StaticMapMarker = [\n  /**\n   * Longitude of the marker\n   */\n  number,\n  /**\n   * latitude of the marker\n   */\n  number,\n  /**\n   * Color of the marker with CSS syntax. Applies only if a custom `markerIcon` is not provided.\n   */\n  string\n];\n\nfunction staticMapMarkerToString(\n  marker: StaticMapMarker,\n  includeColor = true\n): string {\n  let str = `${marker[0]},${marker[1]}`;\n\n  if (marker.length === 3 && includeColor) {\n    str += `,${marker[2]}`;\n  }\n\n  return str;\n}\n\nfunction simplifyAndStringify(path: Array<Position>, maxNbChar = 3000): string {\n  let str = path.map((point) => point.join(\",\")).join(\"|\");\n  let tolerance = 0.000005;\n  const toleranceStep = 0.00001;\n\n  while (str.length > maxNbChar) {\n    const simplerPath = simplify(path, tolerance);\n    // str = simplerPath.map(point => point.join(',')).join('|');\n    str = simplerPath.map((point) => `${point[0]},${point[1]}`).join(\"|\");\n    tolerance += toleranceStep;\n  }\n\n  return str;\n}\n\n/**\n * Construct the URL for a static map centered on one point.\n * Note: this function does not fetch the binary content of the image since\n * the purpose of a static map is generally to have its URL as a `src` property of a <img/> element.\n * If a path is provided and is too long, it will be simplified in an accurate way.\n * @param center\n * @param zoom\n * @param options\n * @returns\n */\nfunction centered(\n  center: Position,\n  zoom: number,\n  options: CenteredStaticMapOptions = {}\n): string {\n  const style = styleToStyle(options.style);\n  const scale = options.hiDPI ? \"@2x\" : \"\";\n  const format = options.format ?? \"png\";\n  let width = ~~(options.width ?? 1024);\n  let height = ~~(options.height ?? 1024);\n\n  if (options.hiDPI) {\n    width = ~~(width / 2);\n    height = ~~(height / 2);\n  }\n\n  const endpoint = new URL(\n    `maps/${encodeURIComponent(style)}/static/${center[0]},${\n      center[1]\n    },${zoom}/${width}x${height}${scale}.${format}`,\n    defaults.maptilerApiURL\n  );\n\n  if (\"attribution\" in options) {\n    endpoint.searchParams.set(\"attribution\", options.attribution.toString());\n  }\n\n  if (\"markers\" in options) {\n    let markerStr = \"\";\n\n    const hasIcon = \"markerIcon\" in options;\n\n    if (hasIcon) {\n      markerStr += `icon:${options.markerIcon}|`;\n    }\n\n    if (hasIcon && \"markerAnchor\" in options) {\n      markerStr += `anchor:${options.markerAnchor}|`;\n    }\n\n    if (hasIcon && options.hiDPI) {\n      markerStr += `scale:2|`;\n    }\n\n    const markerList = Array.isArray(options.markers[0])\n      ? options.markers\n      : [options.markers];\n    markerStr += markerList\n      .map((m) => staticMapMarkerToString(m, !hasIcon))\n      .join(\"|\");\n    endpoint.searchParams.set(\"markers\", markerStr);\n  }\n\n  if (\"path\" in options) {\n    let pathStr = \"\";\n\n    pathStr += `fill:${options.pathFillColor ?? \"none\"}|`;\n\n    if (\"pathStrokeColor\" in options) {\n      pathStr += `stroke:${options.pathStrokeColor}|`;\n    }\n\n    if (\"pathWidth\" in options) {\n      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);\n      pathStr += `width:${pathWidth.toString()}|`;\n    }\n\n    pathStr += simplifyAndStringify(options.path);\n    endpoint.searchParams.set(\"path\", pathStr);\n  }\n\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n\n  return endpoint.toString();\n}\n\n/**\n * Construct the URL for a static map using a bounding box\n * Note: this function does not fetch the binary content of the image since\n * the purpose of a static map is generally to have its URL as a `src` property of a <img/> element.\n * If a path is provided and is too long, it will be simplified in an accurate way.\n * @param boundingBox\n * @param options\n * @returns\n */\nfunction bounded(\n  boundingBox: BBox,\n  options: BoundedStaticMapOptions = {}\n): string {\n  const style = styleToStyle(options.style);\n  const scale = options.hiDPI ? \"@2x\" : \"\";\n  const format = options.format ?? \"png\";\n  let width = ~~(options.width ?? 1024);\n  let height = ~~(options.height ?? 1024);\n\n  if (options.hiDPI) {\n    width = ~~(width / 2);\n    height = ~~(height / 2);\n  }\n\n  const endpoint = new URL(\n    `maps/${encodeURIComponent(style)}/static/${boundingBox[0]},${\n      boundingBox[1]\n    },${boundingBox[2]},${boundingBox[3]}/${width}x${height}${scale}.${format}`,\n    defaults.maptilerApiURL\n  );\n\n  if (\"attribution\" in options) {\n    endpoint.searchParams.set(\"attribution\", options.attribution.toString());\n  }\n\n  if (\"padding\" in options) {\n    endpoint.searchParams.set(\"padding\", options.padding.toString());\n  }\n\n  if (\"markers\" in options) {\n    let markerStr = \"\";\n\n    const hasIcon = \"markerIcon\" in options;\n\n    if (hasIcon) {\n      markerStr += `icon:${options.markerIcon}|`;\n    }\n\n    if (hasIcon && \"markerAnchor\" in options) {\n      markerStr += `anchor:${options.markerAnchor}|`;\n    }\n\n    if (hasIcon && options.hiDPI) {\n      markerStr += `scale:2|`;\n    }\n\n    const markerList = Array.isArray(options.markers[0])\n      ? options.markers\n      : [options.markers];\n    markerStr += markerList\n      .map((m) => staticMapMarkerToString(m, !hasIcon))\n      .join(\"|\");\n    endpoint.searchParams.set(\"markers\", markerStr);\n  }\n\n  if (\"path\" in options) {\n    let pathStr = \"\";\n\n    pathStr += `fill:${options.pathFillColor ?? \"none\"}|`;\n\n    if (\"pathStrokeColor\" in options) {\n      pathStr += `stroke:${options.pathStrokeColor}|`;\n    }\n\n    if (\"pathWidth\" in options) {\n      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);\n      pathStr += `width:${pathWidth.toString()}|`;\n    }\n\n    pathStr += simplifyAndStringify(options.path);\n    endpoint.searchParams.set(\"path\", pathStr);\n  }\n\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n\n  return endpoint.toString();\n}\n\n/**\n * Construct the URL for a static map automatically fitted around the provided path or markers.\n * Note: this function does not fetch the binary content of the image since\n * the purpose of a static map is generally to have its URL as a `src` property of a <img/> element.\n * If a path is provided and is too long, it will be simplified in an accurate way.\n * @param options\n * @returns\n */\nfunction automatic(options: AutomaticStaticMapOptions = {}): string {\n  if (!(\"markers\" in options) && !(\"path\" in options)) {\n    throw new Error(\n      \"Automatic static maps require markers and/or path to be created.\"\n    );\n  }\n\n  const style = styleToStyle(options.style);\n  const scale = options.hiDPI ? \"@2x\" : \"\";\n  const format = options.format ?? \"png\";\n  let width = ~~(options.width ?? 1024);\n  let height = ~~(options.height ?? 1024);\n\n  if (options.hiDPI) {\n    width = ~~(width / 2);\n    height = ~~(height / 2);\n  }\n\n  const endpoint = new URL(\n    `maps/${encodeURIComponent(\n      style\n    )}/static/auto/${width}x${height}${scale}.${format}`,\n    defaults.maptilerApiURL\n  );\n\n  if (\"attribution\" in options) {\n    endpoint.searchParams.set(\"attribution\", options.attribution.toString());\n  }\n\n  if (\"padding\" in options) {\n    endpoint.searchParams.set(\"padding\", options.padding.toString());\n  }\n\n  if (\"markers\" in options) {\n    let markerStr = \"\";\n\n    const hasIcon = \"markerIcon\" in options;\n\n    if (hasIcon) {\n      markerStr += `icon:${options.markerIcon}|`;\n    }\n\n    if (hasIcon && \"markerAnchor\" in options) {\n      markerStr += `anchor:${options.markerAnchor}|`;\n    }\n\n    if (hasIcon && options.hiDPI) {\n      markerStr += `scale:2|`;\n    }\n\n    const markerList = Array.isArray(options.markers[0])\n      ? options.markers\n      : [options.markers];\n    markerStr += markerList\n      .map((m) => staticMapMarkerToString(m, !hasIcon))\n      .join(\"|\");\n    endpoint.searchParams.set(\"markers\", markerStr);\n  }\n\n  if (\"path\" in options) {\n    let pathStr = \"\";\n\n    pathStr += `fill:${options.pathFillColor ?? \"none\"}|`;\n\n    if (\"pathStrokeColor\" in options) {\n      pathStr += `stroke:${options.pathStrokeColor}|`;\n    }\n\n    if (\"pathWidth\" in options) {\n      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);\n      pathStr += `width:${pathWidth.toString()}|`;\n    }\n\n    pathStr += simplifyAndStringify(options.path);\n    endpoint.searchParams.set(\"path\", pathStr);\n  }\n\n  endpoint.searchParams.set(\"key\", options.apiKey ?? config.apiKey);\n\n  return endpoint.toString();\n}\n\n/**\n * The **staticMaps** namespace contains an synchronous function build image URL of static map, as specified by the [MapTiler Static Map API](https://docs.maptiler.com/cloud/api/static-maps/).\n * The URL of static maps can then be used within a `<img />` markup element, as the `src` property value.\n */\nconst staticMaps = {\n  centered,\n  bounded,\n  automatic,\n};\n\nexport { staticMaps };\n","var E=63710088e-1;function h(n){return n*180/Math.PI}function d(n){return n*Math.PI/180}function _(n){return n%1!==0}var B=6378137,x=20037508342789244e-9;var I={};function y(n,t){if(n<0||n>30)throw Error(\"Invalid zoom level\");return _(n)?L(n,t):(I[t]===void 0&&(I[t]={}),Array.isArray(I[t][n])||(I[t][n]=L(n,t)),I[t][n])}function L(n,t){let r=t*Math.pow(2,n);return[r/360,r/(2*Math.PI),r/2,r]}function l(n,t,r=!1,u=512){let{min:o,max:e,sin:s,log:m,round:c}=Math,[a,p,A,i]=y(t,u),M=r?2:1,R=A,f=o(e(s(d(n[1])),-.9999),.9999),P=R+n[0]*a,b=R+.5*m((1+f)/(1-f))*-p;return _(t)||(P=c(P),b=c(b)),P>i*M&&(P=i*M),b>i&&(b=i),[P,b]}function X(n,t,r=512){let{atan:u,exp:o,PI:e}=Math,[s,m,c]=y(t,r),a=(n[1]-c)/-m,p=(n[0]-c)/s,A=h(2*u(o(a))-.5*e);return[p,A]}function T(n){let{tan:t,log:r,PI:u}=Math,o=d(B*n[0]),e=B*r(t(u*.25+d(.5*n[1])));return o>x&&(o=x),o<-x&&(o=-x),e>x&&(e=x),e<-x&&(e=-x),[o,e]}function Y(n){let{atan:t,exp:r,PI:u}=Math,o=h(n[0]/B),e=h(.5*u-2*t(r(-n[1]/B)));return[o,e]}function g(n,t=512){let{floor:r}=Math,u=r(n[0]/t),o=r(n[1]/t);return[u,o]}function O(n,t=512){let[,r,u]=n,o=r*t,e=u*t,s=o+t,m=e+t;return[o,e,s,m]}function Z(n,t,r=512){let u=l(n,t,!1,r);return g(u,r)}function w(n,t,r=512){let[u,o,e]=t,s=l(n,u,!1,r),m=o*r,c=e*r;return[(s[0]-m)/r,(s[1]-c)/r]}function N(n,t){return t===\"WGS84\"?[...Y([n[0],n[1]]),...Y([n[2],n[3]])]:[...T([n[0],n[1]]),...T([n[2],n[3]])]}function v(n,t,r,u=!0,o=\"900913\",e=512){u&&(t=Math.pow(2,r)-1-t);let s=[n*e,(+t+1)*e],m=[(n+1)*e,t*e],c=X(s,r,e),a=X(m,r,e);return o===\"900913\"?[...T(c),...T(a)]:[...c,...a]}function j(n,t,r=!0,u=\"900913\",o=512){let{min:e,max:s,pow:m,floor:c}=Math,a=[n[0],n[1]],p=[n[2],n[3]];u===\"900913\"&&(a=T(a),p=T(p));let A=l(a,t,!1,o),i=l(p,t,!1,o),M=[c(A[0]/o),c((i[0]-1)/o)],R=[c(i[1]/o),c((A[1]-1)/o)],f={minX:e(...M)<0?0:e(...M),minY:e(...R)<0?0:e(...R),maxX:s(...M),maxY:s(...R)};if(r){let P=m(2,t)-1-f.maxY,b=m(2,t)-1-f.minY;f.minY=P,f.maxY=b}return f}var C=2*Math.PI*E;function U(n){return C*Math.cos(n*Math.PI/180)}function Q(n){return(180+n)/360}function G(n){let{PI:t,log:r,tan:u}=Math;return(180-180/t*r(u(t/4+n*t/360)))/360}function W(n,t){return n/U(t)}function k(n){return n*360-180}function D(n){let{PI:t,atan:r,exp:u}=Math,o=180-n*360;return 360/t*r(u(o*t/180))-90}function q(n,t){return n*U(D(t))}function J(n){let{cos:t,PI:r}=Math;return 1/t(n*r/180)}export{q as altitudeFromMercatorZ,j as bboxToXYZBounds,N as convert,D as latFromMercatorY,T as llToMerc,l as llToPX,Z as llToTile,w as llToTilePx,k as lngFromMercatorX,Y as mercToLL,J as mercatorLatScale,Q as mercatorXfromLng,G as mercatorYfromLat,W as mercatorZfromAltitude,X as pxToLL,g as pxToTile,O as tilePxBounds,v as xyzToBBOX};\n//# sourceMappingURL=index.js.map","export const earthRadius = 6371008.8;\n\n/** Convert meters to feet */\nexport function mToFt(m: number): number {\n  return m * 3.28084;\n}\n\n/** Convert degrees to Radians */\nexport function degToRad(degrees: number): number {\n  return ((degrees % 360) * Math.PI) / 180;\n}\n\n/** Convert radians to degrees */\nexport function radToDeg(radians: number): number {\n  return (radians * 180) / Math.PI;\n}\n\n/** Given a latitude and zoom level, determine the max distance each segment can be in meters */\nexport function getZoomLevelResolution(\n  latitude: number,\n  zoom: number,\n  tileSize = 512\n): number {\n  return (\n    ((Math.cos((latitude * Math.PI) / 180.0) * 2 * Math.PI * 6378137) /\n      (tileSize * 2 ** zoom)) *\n    3\n  );\n}\n\n/** Convert a tile's zoom-x-y to a number hash */\nexport function xyzToTileID(x: number, y: number, zoom: number): number {\n  return ((1 << zoom) * y + x) * 32 + zoom;\n}\n","// ripped from https://github.com/Turfjs/turf/blob/master/packages/turf-area/index.ts\nimport { degToRad, earthRadius } from \"./util\";\n\n/**\n * Finds the area of a Polygon or MultiPolygon in square meters.\n */\nexport function area(\n  area:\n    | GeoJSON.Feature<GeoJSON.Polygon | GeoJSON.MultiPolygon>\n    | GeoJSON.Polygon\n    | GeoJSON.MultiPolygon\n) {\n  const geometry = \"geometry\" in area ? area.geometry : area;\n  const type = geometry.type;\n  if (type === \"MultiPolygon\") {\n    return multiPolygonArea(geometry.coordinates);\n  }\n  return polygonArea(geometry.coordinates);\n}\n\n/**\n * Finds the area of a MultiPolygon in square meters.\n */\nexport function multiPolygonArea(\n  multiPoly: GeoJSON.MultiPolygon | GeoJSON.Position[][][]\n): number {\n  const coords = \"coordinates\" in multiPoly ? multiPoly.coordinates : multiPoly;\n  let total = 0;\n  for (const polygon of coords) {\n    total += polygonArea(polygon);\n  }\n  return total;\n}\n\n/**\n * Finds the area of a Polygon in square meters.\n */\nexport function polygonArea(\n  poly: GeoJSON.Polygon | GeoJSON.Position[][]\n): number {\n  const coords = \"coordinates\" in poly ? poly.coordinates : poly;\n  let total = 0;\n  for (const ring of coords) {\n    total += ringArea(ring);\n  }\n  return total;\n}\n\n/**\n * Calculate the approximate area of the polygon were it projected onto the earth.\n * Note that this area will be positive if ring is oriented clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for Polygons on a Sphere\",\n * JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007 https://trs.jpl.nasa.gov/handle/2014/40409\n */\nfunction ringArea(coords: GeoJSON.Position[]): number {\n  let p1;\n  let p2;\n  let p3;\n  let lowerIndex;\n  let middleIndex;\n  let upperIndex;\n  let i;\n  let total = 0;\n  const coordsLength = coords.length;\n\n  if (coordsLength > 2) {\n    for (i = 0; i < coordsLength; i++) {\n      if (i === coordsLength - 2) {\n        // i = N-2\n        lowerIndex = coordsLength - 2;\n        middleIndex = coordsLength - 1;\n        upperIndex = 0;\n      } else if (i === coordsLength - 1) {\n        // i = N-1\n        lowerIndex = coordsLength - 1;\n        middleIndex = 0;\n        upperIndex = 1;\n      } else {\n        // i = 0 to N-3\n        lowerIndex = i;\n        middleIndex = i + 1;\n        upperIndex = i + 2;\n      }\n      p1 = coords[lowerIndex];\n      p2 = coords[middleIndex];\n      p3 = coords[upperIndex];\n      total += (degToRad(p3[0]) - degToRad(p1[0])) * Math.sin(degToRad(p2[1]));\n    }\n\n    total = (total * earthRadius * earthRadius) / 2;\n  }\n  return Math.abs(total);\n}\n","import { earthRadius, degToRad } from \"./util\";\n\n/** Get the distance of a LineString in meters */\nexport function lineDistance(\n  line:\n    | GeoJSON.Feature<GeoJSON.LineString>\n    | GeoJSON.LineString\n    | GeoJSON.Position[]\n) {\n  // grab the coordinates\n  const coordinates =\n    \"geometry\" in line\n      ? line.geometry.coordinates\n      : \"coordinates\" in line\n      ? line.coordinates\n      : line;\n  // iterate through the coordinates and calculate the distance\n  let distance = 0;\n  let prevCoord: GeoJSON.Position | undefined;\n  for (const coordinate of coordinates) {\n    if (prevCoord !== undefined) {\n      distance += pointDistance(prevCoord, coordinate);\n    }\n    prevCoord = coordinate;\n  }\n\n  return distance;\n}\n\n/** Get the distance between two lon-lat pairs in meters */\nexport function pointDistance(\n  from: GeoJSON.Position,\n  to: GeoJSON.Position\n): number {\n  const { pow, sin, cos, sqrt, atan2 } = Math;\n  const dLat = degToRad(to[1] - from[1]);\n  const dLon = degToRad(to[0] - from[0]);\n  const lat1 = degToRad(from[1]);\n  const lat2 = degToRad(to[1]);\n\n  const a =\n    pow(sin(dLat / 2), 2) + pow(sin(dLon / 2), 2) * cos(lat1) * cos(lat2);\n\n  return 2 * atan2(sqrt(a), sqrt(1 - a)) * earthRadius;\n}\n","import { llToTile } from \"web-merc-projection\";\nimport {\n  pointDistance,\n  getZoomLevelResolution,\n  xyzToTileID,\n} from \"../geometry\";\n\nimport type { Point } from \"web-merc-projection\";\n\nexport interface TileID {\n  id: number;\n  x: number;\n  y: number;\n  z: number;\n}\n\nexport interface TileCoverCoordinates {\n  /** Store the coordinates as an ll-pair */\n  coordinate: Point;\n  /** Track the tile relative to the point */\n  tile: TileID;\n}\n\nexport interface TileCoverOutput {\n  coords: TileCoverCoordinates[];\n  tiles: TileID[];\n}\n\n/**\n * Given LineString coordinates, return the web mercator tiles that all the points contain.\n * Breaks the coordinates down into points that are relative to the zoom.\n */\nexport default function tileCover(\n  coordinates: GeoJSON.Position[],\n  zoom: number,\n  tileSize: number\n): TileCoverOutput {\n  const tileHash = new Map<number, TileID>(); // tileHash => { id, x, y, z }\n  const tiles: TileID[] = [];\n  const coords: TileCoverCoordinates[] = [];\n\n  // get the resolution of the zoom level\n  const resolution = getZoomLevelResolution(coordinates[0][1], zoom, tileSize);\n\n  // migrate from coordinates to \"samples\" that are relative to the zoom\n  const samples = sampleProfileLine(coordinates, resolution);\n\n  for (const sample of samples) {\n    const coordinate = sample as unknown as [lon: number, lat: number];\n    // file the file that the coordinate is in\n    const [tileX, tileY] = llToTile(coordinate, zoom, tileSize);\n    // create the tile and store it\n    const id = xyzToTileID(tileX, tileY, zoom);\n    const tile: TileID = { id, x: tileX, y: tileY, z: zoom };\n    tileHash.set(id, tile);\n    // store the coordinates\n    coords.push({ coordinate, tile });\n  }\n  // store the tiles we've found\n  for (const tile of tileHash.values()) tiles.push(tile);\n\n  return { coords, tiles };\n}\n\n/** convert coordinates to samples that have a max distance of the zoom level resolution */\nfunction sampleProfileLine(\n  coordinates: GeoJSON.Position[],\n  resolution: number\n): GeoJSON.Position[] {\n  const samples: GeoJSON.Position[] = [];\n\n  let prevCoord: GeoJSON.Position | undefined;\n  for (const coord of coordinates) {\n    if (prevCoord !== undefined) {\n      const dist = pointDistance(\n        prevCoord as unknown as [lon: number, lat: number],\n        coord as unknown as [lon: number, lat: number]\n      );\n      const numSamples = Math.ceil(dist / resolution);\n\n      for (let i = 0; i <= numSamples - 1; i++) {\n        const sample = [\n          prevCoord[0] + (coord[0] - prevCoord[0]) * (i / numSamples),\n          prevCoord[1] + (coord[1] - prevCoord[1]) * (i / numSamples),\n        ];\n        samples.push(sample);\n      }\n    } else {\n      samples.push(coord);\n    }\n\n    prevCoord = coord;\n  }\n\n  return samples;\n}\n","import { llToTilePx } from \"web-merc-projection\";\n\nimport type { TileImage } from \"./\";\n\nexport type ElevationParser = (\n  r: number,\n  g: number,\n  b: number,\n  a: number\n) => number;\n\n/** Given an RGB or RBGA image and lon-lat coordinate, determine the elevation */\nexport default function getElevation(\n  coord: [lon: number, lat: number],\n  tile: [zoom: number, x: number, y: number],\n  tileSize: number,\n  tileImage: TileImage,\n  elevationParser: ElevationParser = defaultElevationParser\n): number {\n  const { channels, image } = tileImage;\n  let [x, y] = llToTilePx(coord, tile, tileSize);\n  x = clampPixel(x, tileSize);\n  y = clampPixel(y, tileSize);\n  const index = (y * tileSize + x) * channels;\n\n  return elevationParser(\n    image[index],\n    image[index + 1],\n    image[index + 2],\n    channels === 4 ? image[index + 3] : 0\n  );\n}\n\n/** Clamp the pixels to the 0-tileSize bounds */\nfunction clampPixel(n: number, tileSize: number): number {\n  return Math.max(0, Math.min(tileSize, Math.floor(n * tileSize)));\n}\n\n/** Default elevation parser used by Mapbox and Maplibre. Result is in meters */\nexport function defaultElevationParser(\n  r: number,\n  g: number,\n  b: number\n): number {\n  return -10000 + (r * 256 * 256 + g * 256 + b) * 0.1;\n}\n","import tileCover from \"./tileCover\";\nimport getElevation from \"./getElevation\";\nimport { pointDistance, mToFt } from \"../geometry\";\n\nimport type { TileCoverCoordinates, TileID } from \"./tileCover\";\nimport type { ElevationParser } from \"./getElevation\";\nimport type { Feature, LineString } from \"geojson\";\n\nexport * from \"./getElevation\";\nexport * from \"./tileCover\";\n\nexport interface TileImage {\n  channels: 1 | 2 | 3 | 4;\n  image: Uint8ClampedArray;\n}\n\nexport type TileRequest = (\n  x: number,\n  y: number,\n  zoom: number\n) => Promise<TileImage>;\n\nexport interface Options {\n  /** type of metric to use. Meters or feet. Default: meters */\n  metric?: \"m\" | \"ft\";\n  /** Zoom that is queried from the server. Default: 13 */\n  zoom?: number;\n  /** Tile size of the images returned. Default 512 */\n  tileSize?: number;\n  /** Tile Request method */\n  tileRequest: TileRequest;\n  /** Elevation parser. Default: elevation = -10000 + ((R * 256 * 256 + G * 256 + B) * 0.1) */\n  elevationParser?: ElevationParser;\n  /** smooth out the elevation to make the visual aesthetic nicer */\n  smooth?: boolean;\n}\n\nexport interface ElevPoint {\n  /** Distance along path from the starting point in the metric defind by options */\n  distance: number;\n  /** Elevation of the point */\n  elevation: number;\n  /** Coordinates of the point in lat-lon */\n  coordinate: [lon: number, lat: number];\n  /** Tile that the point is in */\n  tile: TileID;\n}\n\nexport interface Output {\n  /** Total length of the path in the metric defined by options */\n  distance: number;\n  /** Minimum elevation of the path */\n  minElevation: number;\n  /** Maximum elevation of the path */\n  maxElevation: number;\n  /** Average elevation of the path */\n  avgElevation: number;\n  /** Elevation at the start of the path */\n  startElevation: number;\n  /** Elevation at the end of the path */\n  endElevation: number;\n  /** Array of points along the path */\n  points: ElevPoint[];\n}\n\n/**\n * Given a GeoJSON LineString or Feature<Linestring>, return the elevation data for the path.\n * This algorithm will automatically break the path into denser segments relative to the zoom level if necessary.\n */\nexport async function profileLineString(\n  path: Feature<LineString> | LineString,\n  options: Options\n): Promise<Output> {\n  // get the tile cover\n  const coordinates =\n    \"geometry\" in path ? path.geometry.coordinates : path.coordinates;\n  const { coords, tiles } = tileCover(\n    coordinates,\n    options.zoom ?? 13,\n    options.tileSize ?? 512\n  );\n  // get tiles\n  const tileCache = await getTiles(tiles, options.tileRequest);\n  // get the elevation data\n  let points = getElevations(\n    coords,\n    tileCache,\n    options.tileSize ?? 512,\n    options.elevationParser\n  );\n  // smooth the elevation data if needed\n  if (options.smooth === true) points = smoothElevation(points);\n  // calculate the output\n  let output = buildOutput(points);\n  // convert to miles if needed\n  if (options.metric === \"ft\") output = toFeet(output);\n\n  return output;\n}\n\n/** Request all the tiles we need */\nasync function getTiles(\n  tiles: TileID[],\n  tileRequest: TileRequest\n): Promise<Map<number, TileImage>> {\n  const tileCache = new Map<number, TileImage>();\n\n  // request all the tiles we need\n  const requests: Array<Promise<TileImage | undefined>> = [];\n  for (const tile of tiles) {\n    requests.push(\n      tileRequest(tile.x, tile.y, tile.z)\n        .then((res: TileImage): TileImage => {\n          tileCache.set(tile.id, res);\n          return res;\n        })\n        .catch((err: unknown) => {\n          console.error(err);\n          return undefined;\n        })\n    );\n  }\n  // wait for all the requests to finish\n  await Promise.allSettled(requests);\n\n  return tileCache;\n}\n\n/** Get the elevation data for each coordinate */\nfunction getElevations(\n  coords: TileCoverCoordinates[],\n  tileCache: Map<number, TileImage>,\n  tileSize: number,\n  elevationParser?: ElevationParser\n): ElevPoint[] {\n  const points: ElevPoint[] = [];\n\n  // get the elevation data for each coordinate\n  let curDistance = 0;\n  let prevCoord: [lon: number, lat: number] | undefined;\n  for (const { tile, coordinate } of coords) {\n    const cTile = tileCache.get(tile.id);\n    if (cTile === undefined)\n      throw new Error(\n        `Missing tile ${tile.id} (${tile.x}-${tile.y}-${tile.z})`\n      );\n    const elevation = getElevation(\n      coordinate,\n      [tile.z, tile.x, tile.y],\n      tileSize,\n      cTile,\n      elevationParser\n    );\n    points.push({\n      distance: curDistance,\n      elevation,\n      coordinate,\n      tile,\n    });\n    // calculate the distance between the points\n    if (prevCoord !== undefined) {\n      curDistance += pointDistance(prevCoord, coordinate);\n    }\n    prevCoord = coordinate;\n  }\n\n  return points;\n}\n\n/** Improve the output to include metrics about the max/min/avg elevation */\nfunction buildOutput(points: ElevPoint[]): Output {\n  // setup variables\n  let minElevation = Infinity;\n  let maxElevation = -Infinity;\n  let totalElevation = 0;\n  // calcuate min, max, and average\n  for (const point of points) {\n    if (point.elevation < minElevation) minElevation = point.elevation;\n    if (point.elevation > maxElevation) maxElevation = point.elevation;\n    totalElevation += point.elevation;\n  }\n\n  return {\n    distance: points[points.length - 1].distance,\n    minElevation,\n    maxElevation,\n    avgElevation: totalElevation / points.length,\n    startElevation: points[0].elevation,\n    endElevation: points[points.length - 1].elevation,\n    points,\n  };\n}\n\n/**\n * Smooth function to make the elevation appear more aesthetically\n * pleaseing without changing the values greatly\n */\nfunction smoothElevation(points: ElevPoint[]): ElevPoint[] {\n  const newPoints: ElevPoint[] = [];\n  let prevPoint: ElevPoint | undefined;\n  for (let i = 0; i < points.length; i++) {\n    const point = points[i];\n    const nextPoint = points[i + 1] ?? points[i];\n    if (prevPoint === undefined) {\n      newPoints.push(point);\n    } else {\n      const newPoint: ElevPoint = {\n        distance: point.distance,\n        elevation:\n          (prevPoint.elevation + point.elevation + nextPoint.elevation) / 3,\n        coordinate: point.coordinate,\n        tile: point.tile,\n      };\n      newPoints.push(newPoint);\n    }\n    prevPoint = point;\n  }\n\n  return newPoints;\n}\n\n/** Convert all output properties from km to miles */\nfunction toFeet(input: Output): Output {\n  const output: Output = {\n    distance: mToFt(input.distance),\n    minElevation: mToFt(input.minElevation),\n    maxElevation: mToFt(input.maxElevation),\n    avgElevation: mToFt(input.avgElevation),\n    startElevation: mToFt(input.startElevation),\n    endElevation: mToFt(input.endElevation),\n    points: input.points.map(({ distance, elevation, coordinate, tile }) => ({\n      distance: mToFt(distance),\n      elevation: mToFt(elevation),\n      coordinate,\n      tile,\n    })),\n  };\n\n  return output;\n}\n"],"names":["__publicField","__async","customMessages","area","llToTile","llToTilePx"],"mappings":"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AE,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAsW,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,OAAM,CAAC,CAAC,CAAC,CAAC,C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"}