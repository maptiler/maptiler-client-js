{"version":3,"file":"maptiler-client.mjs","sources":["../src/config.ts","../src/language.ts","../src/callFetch.ts","../src/defaults.ts","../src/services/ServiceError.ts","../src/services/geocoding.ts","../src/services/geolocation.ts","../src/services/coordinates.ts","../src/services/data.ts","../src/services/simplify.ts","../src/services/staticMaps.ts"],"sourcesContent":["export type FetchFunction = (url: string, options: object) => Promise<any>;\n\nfunction tryGettingFetch() {\n  // this is browser, fetch exists\n  if (typeof self !== \"undefined\") {\n    return fetch.bind(self);\n  }\n\n  if (typeof global !== \"undefined\" && global.fetch) {\n    return global.fetch;\n  }\n\n  return null;\n}\n\n/**\n * The configuration object definition\n */\nclass ClientConfig {\n  /**\n   * MapTiler Cloud API key\n   */\n  private _apiKey = \"Not defined yet.\";\n\n  /**\n   * The fetch function. To be set if in Node < 18, otherwise\n   * will be automatically resolved.\n   */\n  private _fetch: FetchFunction | null = tryGettingFetch();\n\n  /**\n   * Set the MapTiler Cloud API key\n   */\n  set apiKey(k: string) {\n    this._apiKey = k;\n  }\n\n  /**\n   * Get the MapTiler Cloud API key\n   */\n  get apiKey(): string {\n    return this._apiKey;\n  }\n\n  /**\n   * Set a the custom fetch function to replace the default one\n   */\n  set fetch(f: FetchFunction) {\n    this._fetch = f;\n  }\n\n  /**\n   * Get the fetch fucntion\n   */\n  get fetch(): FetchFunction | null {\n    return this._fetch;\n  }\n}\n\n/**\n * Configuration object\n */\nconst config = new ClientConfig();\n\nexport { ClientConfig, config };\n","/**\n * Languages. Note that not all the languages of this list are available but the compatibility list may be expanded in the future.\n */\nconst LanguageGeocoding = {\n  AUTO: \"auto\",\n  ALBANIAN: \"sq\",\n  ARABIC: \"ar\",\n  ARMENIAN: \"hy\",\n  AZERBAIJANI: \"az\",\n  BELORUSSIAN: \"be\",\n  BOSNIAN: \"bs\",\n  BRETON: \"br\",\n  BULGARIAN: \"bg\",\n  CATALAN: \"ca\",\n  CHINESE: \"zh\",\n  CROATIAN: \"hr\",\n  CZECH: \"cs\",\n  DANISH: \"da\",\n  DUTCH: \"nl\",\n  ENGLISH: \"en\",\n  ESPERANTO: \"eo\",\n  ESTONIAN: \"et\",\n  FINNISH: \"fi\",\n  FRENCH: \"fr\",\n  FRISIAN: \"fy\",\n  GEORGIAN: \"ka\",\n  GERMAN: \"de\",\n  GREEK: \"el\",\n  HEBREW: \"he\",\n  HUNGARIAN: \"hu\",\n  ICELANDIC: \"is\",\n  IRISH: \"ga\",\n  ITALIAN: \"it\",\n  JAPANESE: \"ja\",\n  KANNADA: \"kn\",\n  KAZAKH: \"kk\",\n  KOREAN: \"ko\",\n  ROMAN_LATIN: \"la\",\n  LATVIAN: \"lv\",\n  LITHUANIAN: \"lt\",\n  LUXEMBOURGISH: \"lb\",\n  MACEDONIAN: \"mk\",\n  MALTESE: \"mt\",\n  NORWEGIAN: \"no\",\n  POLISH: \"pl\",\n  PORTUGUESE: \"pt\",\n  ROMANIAN: \"ro\",\n  ROMANSH: \"rm\",\n  RUSSIAN: \"ru\",\n  SCOTTISH_GAELIC: \"gd\",\n  SERBIAN_CYRILLIC: \"sr\",\n  SLOVAK: \"sk\",\n  SLOVENE: \"sl\",\n  SPANISH: \"es\",\n  SWEDISH: \"sv\",\n  THAI: \"th\",\n  TURKISH: \"tr\",\n  UKRAINIAN: \"uk\",\n  WELSH: \"cy\",\n};\n\nconst languageCodeSet = new Set(Object.values(LanguageGeocoding));\n\ntype Values<T> = T[keyof T];\n\n/**\n * Built-in languages values as strings\n */\ntype LanguageGeocodingString = Values<typeof LanguageGeocoding>;\n\nfunction getAutoLanguageGeocoding(): LanguageGeocodingString {\n  if (typeof navigator === \"undefined\") {\n    return Intl.DateTimeFormat()\n      .resolvedOptions()\n      .locale.split(\"-\")[0] as LanguageGeocodingString;\n  }\n\n  const canditatelangs = Array.from(\n    new Set(navigator.languages.map((l) => l.split(\"-\")[0]))\n  ).filter((l) => languageCodeSet.has(l as LanguageGeocodingString));\n\n  return canditatelangs.length\n    ? (canditatelangs[0] as LanguageGeocodingString)\n    : LanguageGeocoding.ENGLISH;\n}\n\nexport { LanguageGeocoding, LanguageGeocodingString, getAutoLanguageGeocoding };\n","import { config } from \"./config\";\n\nexport async function callFetch(resource, options = {}) {\n  if (config.fetch === null) {\n    throw new Error(\n      \"The fetch function was not found. If on NodeJS < 18 please specify the fetch function with config.fetch\"\n    );\n  }\n\n  return config.fetch(resource, options);\n}\n","/**\n * Some default settings for the SDK\n */\nconst defaults = {\n  maptilerApiURL: \"https://api.maptiler.com/\",\n  mapStyle: \"streets-v2\",\n};\n\nObject.freeze(defaults);\n\nexport { defaults };\n","/**\n * A ServiceError is an Error that includes the HTTP response details\n */\nexport class ServiceError extends Error {\n  constructor(public res: Response, customMessage = \"\") {\n    super(\n      `Call to enpoint ${res.url} failed with the status code ${res.status}. ${customMessage}`\n    );\n  }\n}\n","import { callFetch } from \"../callFetch\";\nimport { config } from \"../config\";\nimport { defaults } from \"../defaults\";\nimport { Bbox, LngLat } from \"../generalTypes\";\nimport {\n  getAutoLanguageGeocoding,\n  LanguageGeocoding,\n  LanguageGeocodingString,\n} from \"../language\";\nimport { ServiceError } from \"./ServiceError\";\n\nexport type GeocodingOptions = {\n  /**\n   * Only search for results in the specified area.\n   */\n  bbox?: Bbox;\n\n  /**\n   * Prefer results close to a specific location.\n   */\n  proximity?: LngLat;\n\n  /**\n   * Prefer results in specific language. It’s possible to specify multiple values.\n   */\n  language?: LanguageGeocodingString | Array<LanguageGeocodingString>;\n};\n\nconst customMessages = {\n  400: \"Query too long / Invalid parameters\",\n  403: \"Key is missing, invalid or restricted\",\n};\n\n/**\n * Performs a forward geocoding query to MapTiler API.\n * Providing a human readable place name (of a city, country, street, etc.), the function returns\n * a list of candidate locations including longitude and latitude.\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/geocoding/#search-by-name-forward\n * @param query\n * @param options\n * @returns\n */\nasync function forward(query, options: GeocodingOptions = {}) {\n  const endpoint = new URL(\n    `geocoding/${encodeURIComponent(query)}.json`,\n    defaults.maptilerApiURL\n  );\n  endpoint.searchParams.set(\"key\", config.apiKey);\n\n  if (\"bbox\" in options) {\n    const bbox = Array.isArray(options.bbox) ? {southWest: { lng: options.bbox[0], lat: options.bbox[1]}, northEast: { lng: options.bbox[2], lat: options.bbox[3]}} : options.bbox;\n    endpoint.searchParams.set(\n      \"bbox\",\n      [\n        bbox.southWest.lng,\n        bbox.southWest.lat,\n        bbox.northEast.lng,\n        bbox.northEast.lat,\n      ].join(\",\")\n    );\n  }\n\n  if (\"proximity\" in options) {\n    endpoint.searchParams.set(\n      \"proximity\",\n      [options.proximity.lng, options.proximity.lat].join(\",\")\n    );\n  }\n\n  if (\"language\" in options) {\n    const languages = Array.from(\n      new Set(\n        (Array.isArray(options.language)\n          ? options.language\n          : [options.language]\n        ).map((lang) =>\n          lang === LanguageGeocoding.AUTO ? getAutoLanguageGeocoding() : lang\n        )\n      )\n    ).join(\",\");\n\n    endpoint.searchParams.set(\"language\", languages);\n  }\n\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages ? customMessages[res.status] : \"\"\n    );\n  }\n\n  const obj = await res.json();\n  return obj;\n}\n\n\nexport type ReverseGeocodingOptions = {\n  /**\n   * Prefer results in specific language. It’s possible to specify multiple values.\n   */\n  language?: LanguageGeocodingString | Array<LanguageGeocodingString>;\n};\n\n/**\n * Perform a reverse geocoding query to MapTiler API.\n * Providing a longitude and latitude, this function returns a set of human readable information abou this place (country, city, street, etc.)\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/geocoding/#search-by-coordinates-reverse\n * @param lngLat\n * @param options\n * @returns\n */\nasync function reverse(lngLat: LngLat, options: ReverseGeocodingOptions = {}) {\n  const endpoint = new URL(\n    `geocoding/${lngLat.lng},${lngLat.lat}.json`,\n    defaults.maptilerApiURL\n  );\n  endpoint.searchParams.set(\"key\", config.apiKey);\n\n  if (\"language\" in options) {\n    const languages = Array.from(\n      new Set(\n        (Array.isArray(options.language)\n          ? options.language\n          : [options.language]\n        ).map((lang) =>\n          lang === LanguageGeocoding.AUTO ? getAutoLanguageGeocoding() : lang\n        )\n      )\n    ).join(\",\");\n\n    endpoint.searchParams.set(\"language\", languages);\n  }\n\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages ? customMessages[res.status] : \"\"\n    );\n  }\n\n  const obj = await res.json();\n  return obj;\n}\n\n/**\n * The **geocoding** namespace contains asynchronous functions to call the [MapTiler Geocoding API](https://docs.maptiler.com/cloud/api/geocoding/).\n * The **Geocoding API** provides ways to get geographic coordinates from a human-readable search query of a place (forward geocoding)\n * and to get the location details (country, city, street, etc.) from a geographic coordinate (reverse geocoding);\n */\nconst geocoding = {\n  forward,\n  reverse,\n};\n\nexport { geocoding };\n","import { callFetch } from \"../callFetch\";\nimport { config } from \"../config\";\nimport { defaults } from \"../defaults\";\nimport { ServiceError } from \"./ServiceError\";\n\nconst customMessages = {\n  403: \"Key is missing, invalid or restricted\",\n};\n\n/**\n * Looks up geolocation details from IP address using MapTiler API.\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/geolocation/#ip-geolocation\n * @returns\n */\nasync function info() {\n  const endpoint = new URL(`geolocation/ip.json`, defaults.maptilerApiURL);\n  endpoint.searchParams.set(\"key\", config.apiKey);\n  const urlWithParams = endpoint.toString();\n\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages ? customMessages[res.status] : \"\"\n    );\n  }\n\n  const obj = await res.json();\n  return obj;\n}\n\n/**\n * The **geolocation** namespace contains an asynchronous function to call the [MapTiler Geolocation API](https://docs.maptiler.com/cloud/api/geolocation/).\n * The **Geolocation API** provides a way to retrieve the IP address as well as geographic informations of a machine performing the query (most likely: a user)\n */\nconst geolocation = {\n  info,\n};\n\nexport { geolocation };\n","import { callFetch } from \"../callFetch\";\nimport { config } from \"../config\";\nimport { defaults } from \"../defaults\";\nimport { LngLat } from \"../generalTypes\";\nimport { ServiceError } from \"./ServiceError\";\n\nexport type CoordinatesSearchOptions = {\n  /**\n   * Maximum number of results returned (default: 10)\n   */\n  limit?: number;\n\n  /**\n   *  Show detailed transformations for each CRS (default: false)\n   */\n  transformations?: boolean;\n\n  /**\n   * Show exports in WKT and Proj4 notations (default: false)\n   */\n  exports?: boolean;\n};\n\nconst customMessages = {\n  403: \"Key is missing, invalid or restricted\",\n};\n\n/**\n * Search information about coordinate systems using MapTiler API.\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/coordinates/#search-coordinate-systems\n * @param query Can be any kind of CRS by name or code\n * @param options\n * @returns\n */\nasync function search(query: string, options: CoordinatesSearchOptions = {}) {\n  const endpoint = new URL(\n    `coordinates/search/${query}.json`,\n    defaults.maptilerApiURL\n  );\n  endpoint.searchParams.set(\"key\", config.apiKey);\n\n  if (\"limit\" in options) {\n    endpoint.searchParams.set(\"limit\", options.limit.toString());\n  }\n\n  if (\"transformations\" in options) {\n    endpoint.searchParams.set(\n      \"transformations\",\n      options.transformations.toString()\n    );\n  }\n\n  if (\"exports\" in options) {\n    endpoint.searchParams.set(\"exports\", options.exports.toString());\n  }\n\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages ? customMessages[res.status] : \"\"\n    );\n  }\n\n  const obj = await res.json();\n  return obj;\n}\n\n/**\n * Options that can be provided when transforming a coordinate from one CRS to another.\n */\nexport type CoordinatesTransformOptions = {\n  /**\n   * Source coordinate reference system (default: 4326)\n   */\n  sourceCrs?: number;\n\n  /**\n   * Target coordinate reference system (default: 4326)\n   */\n  targetCrs?: number;\n\n  /**\n   * List of codes of operations\n   */\n  operations?: number | Array<number>;\n};\n\n/**\n * Transforms coordinates from a source reference system to a target reference system using MapTiler API.\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/coordinates/#transform-coordinates\n * @param coordinates\n * @param options\n * @returns\n */\nasync function transform(\n  coordinates: LngLat | Array<LngLat>,\n  options: CoordinatesTransformOptions = {}\n) {\n  const coordinatesStr = (\n    Array.isArray(coordinates) ? coordinates : [coordinates]\n  )\n    .map((coord) => `${coord.lng},${coord.lat}`)\n    .join(\";\");\n\n  const endpoint = new URL(\n    `coordinates/transform/${coordinatesStr}.json`,\n    defaults.maptilerApiURL\n  );\n  endpoint.searchParams.set(\"key\", config.apiKey);\n\n  if (\"sourceCrs\" in options) {\n    endpoint.searchParams.set(\"s_srs\", options.sourceCrs.toString());\n  }\n\n  if (\"targetCrs\" in options) {\n    endpoint.searchParams.set(\"t_srs\", options.targetCrs.toString());\n  }\n\n  if (\"operations\" in options) {\n    endpoint.searchParams.set(\n      \"ops\",\n      (Array.isArray(options.operations)\n        ? options.operations\n        : [options.operations]\n      ).join(\"|\")\n    );\n  }\n\n  const urlWithParams = endpoint.toString();\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages ? customMessages[res.status] : \"\"\n    );\n  }\n\n  const obj = await res.json();\n  return obj;\n}\n\n/**\n * The **coordinate** namespace contains asynchronous functions to call the [MapTiler Coordinate API](https://docs.maptiler.com/cloud/api/coordinates/).\n * The goal of the **Coordinate API* is query information about spatial coordinate reference system (CRS) as well as to transform coordinates from one CRS to another.\n */\nconst coordinates = {\n  search,\n  transform,\n};\n\nexport { coordinates };\n","import { callFetch } from \"../callFetch\";\nimport { config } from \"../config\";\nimport { defaults } from \"../defaults\";\nimport { ServiceError } from \"./ServiceError\";\n\nconst customMessages = {\n  403: \"Key is missing, invalid or restricted\",\n};\n\n/**\n * Get user data and returns it as GeoJSON using the MapTiler API.\n * Learn more on the MapTiler API reference page: https://docs.maptiler.com/cloud/api/data/#geojson\n * @param dataId\n * @returns\n */\nasync function get(dataId: string) {\n  const endpoint = new URL(\n    `data/${encodeURIComponent(dataId)}/features.json`,\n    defaults.maptilerApiURL\n  );\n  endpoint.searchParams.set(\"key\", config.apiKey);\n  const urlWithParams = endpoint.toString();\n\n  const res = await callFetch(urlWithParams);\n\n  if (!res.ok) {\n    throw new ServiceError(\n      res,\n      res.status in customMessages ? customMessages[res.status] : \"\"\n    );\n  }\n\n  const obj = await res.json();\n  return obj;\n}\n\n/**\n * The **data** namespace contains an asynchronous function to call the [MapTiler Data API](https://docs.maptiler.com/cloud/api/data/).\n * The **Data API** provides a way to retrieve user data in GeoJSON format.\n */\nconst data = {\n  get,\n};\n\nexport { data };\n","/**\\\n * This code is borrowed from https://github.com/mourner/simplify-js and reworked a little.\n */\n\nimport { LngLatArray } from \"../generalTypes\";\n\n// square distance from a point to a segment\nfunction getSqSegDist(\n  p: LngLatArray,\n  p1: LngLatArray,\n  p2: LngLatArray\n): number {\n  let x = p1[0],\n    y = p1[1],\n    dx = p2[0] - x,\n    dy = p2[1] - y;\n\n  if (dx !== 0 || dy !== 0) {\n    const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n\n    if (t > 1) {\n      x = p2[0];\n      y = p2[1];\n    } else if (t > 0) {\n      x += dx * t;\n      y += dy * t;\n    }\n  }\n\n  dx = p[0] - x;\n  dy = p[1] - y;\n\n  return dx * dx + dy * dy;\n}\n\nfunction simplifyDPStep(\n  points: Array<LngLatArray>,\n  first: number,\n  last: number,\n  sqTolerance: number,\n  simplified: Array<LngLatArray>\n) {\n  let maxSqDist = sqTolerance,\n    index;\n\n  for (let i = first + 1; i < last; i++) {\n    const sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n    if (sqDist > maxSqDist) {\n      index = i;\n      maxSqDist = sqDist;\n    }\n  }\n\n  if (maxSqDist > sqTolerance) {\n    if (index - first > 1) {\n      simplifyDPStep(points, first, index, sqTolerance, simplified);\n    }\n    simplified.push(points[index]);\n\n    if (last - index > 1) {\n      simplifyDPStep(points, index, last, sqTolerance, simplified);\n    }\n  }\n}\n\n// simplification using Ramer-Douglas-Peucker algorithm\nfunction simplifyDouglasPeucker(\n  points: Array<LngLatArray>,\n  sqTolerance: number\n): Array<LngLatArray> {\n  const last = points.length - 1;\n  const simplified = [points[0]];\n  simplifyDPStep(points, 0, last, sqTolerance, simplified);\n  simplified.push(points[last]);\n  return simplified;\n}\n\n// both algorithms combined for awesome performance\nexport default function simplify(\n  points: Array<LngLatArray>,\n  tolerance: number\n): Array<LngLatArray> {\n  if (points.length <= 2) {\n    return points;\n  }\n\n  const sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n  const simplePoints = simplifyDouglasPeucker(points, sqTolerance);\n  return simplePoints;\n}\n","import { config } from \"../config\";\nimport { defaults } from \"../defaults\";\nimport { Bbox, LngLatArray, LngLat } from \"../generalTypes\";\nimport simplify from \"./simplify\";\n\n/**\n * Base set of options that can be provided to all the types of static maps\n */\nexport type StaticMapBaseOptions = {\n  /**\n   * Style of the map (not full style URL). Example: \"winter\", \"streets-v2\".\n   * Default: `\"streets-v2\"`\n   */\n  style?: string;\n\n  /**\n   * Double the size of the static map image to support hiDPI/Retina monitors.\n   * Default: `false`\n   */\n  hiDPI?: boolean;\n\n  /**\n   * Image format.\n   * Default: `\"png\"`\n   */\n  format?: \"png\" | \"jpg\" | \"webp\";\n\n  /**\n   * Width of the output image. Maximum value: `2048`.\n   * Default: `1024`\n   */\n  width?: number;\n\n  /**\n   * Height of the output image. Maximum value: `2048`.\n   * Default: `1024`\n   */\n  height?: number;\n\n  /**\n   * Placement of the attribution. Can also be set to `false` to not show attribution.\n   * Default: `\"bottomright\"`\n   */\n  attribution?: \"bottomright\" | \"bottomleft\" | \"topleft\" | \"topright\" | false;\n\n  /**\n   * A marker or list of markers to show on the map\n   * Default: none provided\n   */\n  marker?: StaticMapMarker | Array<StaticMapMarker>;\n\n  /**\n   * URL of the marker image. Applies only if one or multiple markers positions are provided.\n   * Default: none provided\n   */\n  markerIcon?: string;\n\n  /**\n   * Position of the marker regarding its coordinates. Applies only:\n   * - with a custom icon provided with `markerIcon`\n   * - if one or multiple markers positions are provided.\n   * Default: `\"bottom\"`\n   */\n  markerAnchor?:\n    | \"top\"\n    | \"left\"\n    | \"bottom\"\n    | \"right\"\n    | \"center\"\n    | \"topleft\"\n    | \"bottomleft\"\n    | \"topright\"\n    | \"bottomright\";\n\n  /**\n   * Draw a path or polygon on top of the map. If the path is too long it will be simplified, yet remaining accurate.\n   * Default: none provided\n   */\n  path?: Array<LngLatArray>;\n\n  /**\n   * Color of the path line. The color must be CSS compatible.\n   * Examples:\n   * - long form hex without transparency `\"#FF0000\"` (red)\n   * - short form hex without transparency `\"#F00\"` (red)\n   * - long form hex with transparency `\"#FF000008\"` (red, half opacity)\n   * - short form hex with transparency `\"#F008\"` (red, half opacity)\n   * - CSS color shorthands: `\"red\"`, `\"chartreuse\"`, etc.\n   * - decimal RGB values without transparency: `\"rgb(128, 100, 255)\"`\n   * - decimal RGB values with transparency: `\"rgb(128, 100, 255, 0.5)\"`\n   * Default: `\"blue\"`\n   */\n  pathStrokeColor?: string;\n\n  /**\n   * Color of the filling, also works if the polygon is not closed. The color must be CSS compatible.\n   * Examples:\n   * - long form hex without transparency `\"#FF0000\"` (red)\n   * - short form hex without transparency `\"#F00\"` (red)\n   * - long form hex with transparency `\"#FF000008\"` (red, half opacity)\n   * - short form hex with transparency `\"#F008\"` (red, half opacity)\n   * - CSS color shorthands: `\"red\"`, `\"chartreuse\"`, etc.\n   * - decimal RGB values without transparency: `\"rgb(128, 100, 255)\"`\n   * - decimal RGB values with transparency: `\"rgb(128, 100, 255, 0.5)\"`\n   * Default: none (transparent filling)\n   */\n  pathFillColor?: string;\n\n  /**\n   * Width of the path line in pixel. It can be floating point precision (ex: `0.5`)\n   * Default: `1` if `hiDPI` is `false` and `2` if `hiDPI` is `true`.\n   */\n  pathWidth?: number;\n};\n\n/**\n * Options that can be provided to centered static maps\n */\nexport type CenteredStaticMapOptions = StaticMapBaseOptions;\n\n/**\n * Options that can be provided to bounded static maps\n */\nexport type BoundedStaticMapOptions = StaticMapBaseOptions & {\n  /**\n   * Extra space added around the regio of interest, in percentage.\n   * Default: `0.1` (for 10%)\n   */\n  padding?: number;\n};\n\n/**\n * Options that can be provided to automatic static maps\n */\nexport type AutomaticStaticMapOptions = BoundedStaticMapOptions;\n\n/**\n * Definition of a maker to show on a static map\n */\nexport type StaticMapMarker = {\n  /**\n   * Longitude of the marker\n   */\n  lng: number;\n  /**\n   * latitude of the marker\n   */\n  lat: number;\n  /**\n   * Color of the marker with CSS syntax. Applies only if a custom `markerIcon` is not provided.\n   */\n  color?: string;\n};\n\nfunction staticMapMarkerToString(marker: StaticMapMarker, includeColor = true) {\n  let str = `${marker.lng},${marker.lat}`;\n\n  if (marker.color && includeColor) {\n    str += `,${marker.color}`;\n  }\n\n  return str;\n}\n\nfunction simplifyAndStringify(\n  path: Array<LngLatArray>,\n  maxNbChar = 3000\n): string {\n  let str = path.map((point) => point.join(\",\")).join(\"|\");\n  let tolerance = 0.000005;\n  const toleranceStep = 0.00001;\n\n  while (str.length > maxNbChar) {\n    const simplerPath = simplify(path, tolerance);\n    // str = simplerPath.map(point => point.join(',')).join('|');\n    str = simplerPath.map((point) => `${point[0]},${point[1]}`).join(\"|\");\n    tolerance += toleranceStep;\n  }\n\n  return str;\n}\n\n/**\n * Construct the URL for a static map centered on one point.\n * Note: this function does not fetch the binary content of the image since\n * the purpose of a static map is generally to have its URL as a `src` property of a <img/> element.\n * If a path is provided and is too long, it will be simplified in an accurate way.\n * @param center\n * @param zoom\n * @param options\n * @returns\n */\nfunction centered(\n  center: LngLat,\n  zoom: number,\n  options: CenteredStaticMapOptions = {}\n): string {\n  const style = options.style ?? defaults.mapStyle;\n  const scale = options.hiDPI ? \"@2x\" : \"\";\n  const format = options.format ?? \"png\";\n  let width = ~~(options.width ?? 1024);\n  let height = ~~(options.height ?? 1024);\n\n  if (options.hiDPI) {\n    width = ~~(width / 2);\n    height = ~~(height / 2);\n  }\n\n  const endpoint = new URL(\n    `maps/${encodeURIComponent(style)}/static/${center.lng},${\n      center.lat\n    },${zoom}/${width}x${height}${scale}.${format}`,\n    defaults.maptilerApiURL\n  );\n\n  if (\"attribution\" in options) {\n    endpoint.searchParams.set(\"attribution\", options.attribution.toString());\n  }\n\n  if (\"marker\" in options) {\n    let markerStr = \"\";\n\n    const hasIcon = \"markerIcon\" in options;\n\n    if (hasIcon) {\n      markerStr += `icon:${options.markerIcon}|`;\n    }\n\n    if (hasIcon && \"markerAnchor\" in options) {\n      markerStr += `anchor:${options.markerAnchor}|`;\n    }\n\n    if (hasIcon && options.hiDPI) {\n      markerStr += `scale:2|`;\n    }\n\n    const markerList = Array.isArray(options.marker)\n      ? options.marker\n      : [options.marker];\n    markerStr += markerList\n      .map((m) => staticMapMarkerToString(m, !hasIcon))\n      .join(\"|\");\n    endpoint.searchParams.set(\"markers\", markerStr);\n  }\n\n  if (\"path\" in options) {\n    let pathStr = \"\";\n\n    pathStr += `fill:${options.pathFillColor ?? \"none\"}|`;\n\n    if (\"pathStrokeColor\" in options) {\n      pathStr += `stroke:${options.pathStrokeColor}|`;\n    }\n\n    if (\"pathWidth\" in options) {\n      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);\n      pathStr += `width:${pathWidth.toString()}|`;\n    }\n\n    pathStr += simplifyAndStringify(options.path);\n    endpoint.searchParams.set(\"path\", pathStr);\n  }\n\n  endpoint.searchParams.set(\"key\", config.apiKey);\n\n  return endpoint.toString();\n}\n\n/**\n * Construct the URL for a static map using a bounding box\n * Note: this function does not fetch the binary content of the image since\n * the purpose of a static map is generally to have its URL as a `src` property of a <img/> element.\n * If a path is provided and is too long, it will be simplified in an accurate way.\n * @param boundingBox\n * @param options\n * @returns\n */\nfunction bounded(boundingBox: Bbox, options: BoundedStaticMapOptions = {}) {\n  const style = options.style ?? defaults.mapStyle;\n  const scale = options.hiDPI ? \"@2x\" : \"\";\n  const format = options.format ?? \"png\";\n  let width = ~~(options.width ?? 1024);\n  let height = ~~(options.height ?? 1024);\n\n  if (options.hiDPI) {\n    width = ~~(width / 2);\n    height = ~~(height / 2);\n  }\n\n  const bbox = Array.isArray(boundingBox) ? {southWest: { lng: boundingBox[0], lat: boundingBox[1]}, northEast: { lng: boundingBox[2], lat: boundingBox[3]}} : boundingBox;\n\n  const endpoint = new URL(\n    `maps/${encodeURIComponent(style)}/static/${bbox.southWest.lng},${\n      bbox.southWest.lat\n    },${bbox.northEast.lng},${\n      bbox.northEast.lat\n    }/${width}x${height}${scale}.${format}`,\n    defaults.maptilerApiURL\n  );\n\n  if (\"attribution\" in options) {\n    endpoint.searchParams.set(\"attribution\", options.attribution.toString());\n  }\n\n  if (\"padding\" in options) {\n    endpoint.searchParams.set(\"padding\", options.padding.toString());\n  }\n\n  if (\"marker\" in options) {\n    let markerStr = \"\";\n\n    const hasIcon = \"markerIcon\" in options;\n\n    if (hasIcon) {\n      markerStr += `icon:${options.markerIcon}|`;\n    }\n\n    if (hasIcon && \"markerAnchor\" in options) {\n      markerStr += `anchor:${options.markerAnchor}|`;\n    }\n\n    if (hasIcon && options.hiDPI) {\n      markerStr += `scale:2|`;\n    }\n\n    const markerList = Array.isArray(options.marker)\n      ? options.marker\n      : [options.marker];\n    markerStr += markerList\n      .map((m) => staticMapMarkerToString(m, !hasIcon))\n      .join(\"|\");\n    endpoint.searchParams.set(\"markers\", markerStr);\n  }\n\n  if (\"path\" in options) {\n    let pathStr = \"\";\n\n    pathStr += `fill:${options.pathFillColor ?? \"none\"}|`;\n\n    if (\"pathStrokeColor\" in options) {\n      pathStr += `stroke:${options.pathStrokeColor}|`;\n    }\n\n    if (\"pathWidth\" in options) {\n      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);\n      pathStr += `width:${pathWidth.toString()}|`;\n    }\n\n    pathStr += simplifyAndStringify(options.path);\n    endpoint.searchParams.set(\"path\", pathStr);\n  }\n\n  endpoint.searchParams.set(\"key\", config.apiKey);\n\n  return endpoint.toString();\n}\n\n/**\n * Construct the URL for a static map automatically fitted around the provided path or markers.\n * Note: this function does not fetch the binary content of the image since\n * the purpose of a static map is generally to have its URL as a `src` property of a <img/> element.\n * If a path is provided and is too long, it will be simplified in an accurate way.\n * @param options\n * @returns\n */\nfunction automatic(options: AutomaticStaticMapOptions = {}) {\n  if (!(\"marker\" in options) && !(\"path\" in options)) {\n    throw new Error(\n      \"Automatic static maps require markers and/or path to be created.\"\n    );\n  }\n\n  const style = options.style ?? defaults.mapStyle;\n  const scale = options.hiDPI ? \"@2x\" : \"\";\n  const format = options.format ?? \"png\";\n  let width = ~~(options.width ?? 1024);\n  let height = ~~(options.height ?? 1024);\n\n  if (options.hiDPI) {\n    width = ~~(width / 2);\n    height = ~~(height / 2);\n  }\n\n  const endpoint = new URL(\n    `maps/${encodeURIComponent(\n      style\n    )}/static/auto/${width}x${height}${scale}.${format}`,\n    defaults.maptilerApiURL\n  );\n\n  if (\"attribution\" in options) {\n    endpoint.searchParams.set(\"attribution\", options.attribution.toString());\n  }\n\n  if (\"padding\" in options) {\n    endpoint.searchParams.set(\"padding\", options.padding.toString());\n  }\n\n  if (\"marker\" in options) {\n    let markerStr = \"\";\n\n    const hasIcon = \"markerIcon\" in options;\n\n    if (hasIcon) {\n      markerStr += `icon:${options.markerIcon}|`;\n    }\n\n    if (hasIcon && \"markerAnchor\" in options) {\n      markerStr += `anchor:${options.markerAnchor}|`;\n    }\n\n    if (hasIcon && options.hiDPI) {\n      markerStr += `scale:2|`;\n    }\n\n    const markerList = Array.isArray(options.marker)\n      ? options.marker\n      : [options.marker];\n    markerStr += markerList\n      .map((m) => staticMapMarkerToString(m, !hasIcon))\n      .join(\"|\");\n    endpoint.searchParams.set(\"markers\", markerStr);\n  }\n\n  if (\"path\" in options) {\n    let pathStr = \"\";\n\n    pathStr += `fill:${options.pathFillColor ?? \"none\"}|`;\n\n    if (\"pathStrokeColor\" in options) {\n      pathStr += `stroke:${options.pathStrokeColor}|`;\n    }\n\n    if (\"pathWidth\" in options) {\n      const pathWidth = options.pathWidth / (options.hiDPI ? 2 : 1);\n      pathStr += `width:${pathWidth.toString()}|`;\n    }\n\n    pathStr += simplifyAndStringify(options.path);\n    endpoint.searchParams.set(\"path\", pathStr);\n  }\n\n  endpoint.searchParams.set(\"key\", config.apiKey);\n\n  return endpoint.toString();\n}\n\n/**\n * The **staticMaps** namespace contains an synchronous function build image URL of static map, as specified by the [MapTiler Static Map API](https://docs.maptiler.com/cloud/api/static-maps/).\n * The URL of static maps can then be used within a `<img />` markup element, as the `src` property value.\n */\nconst staticMaps = {\n  centered,\n  bounded,\n  automatic,\n};\n\nexport { staticMaps };\n"],"names":["__async","customMessages","coordinates"],"mappings":"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"}